<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>vividadada 的地下城大冒險</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wangchou.github.io/"/>
  <updated>2017-12-28T03:07:45.512Z</updated>
  <id>http://wangchou.github.io/</id>
  
  <author>
    <name>kindalu</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度工作力(Deep Work)書摘</title>
    <link href="http://wangchou.github.io/2017/12/28/%E3%80%8C%E6%B7%B1%E5%BA%A6%E5%B7%A5%E4%BD%9C%E5%8A%9B%E3%80%8D%E6%9B%B8%E6%91%98%20(Deep%20work)/"/>
    <id>http://wangchou.github.io/2017/12/28/「深度工作力」書摘 (Deep work)/</id>
    <published>2017-12-28T03:22:00.000Z</published>
    <updated>2017-12-28T03:07:45.512Z</updated>
    
    <content type="html"><![CDATA[<p><space><space></space></space></p><p><space><space></space></space></p><h3 id="我將過專注的生活，因為那是最好的一種生活-—-Winifred-Gallagher"><a href="#我將過專注的生活，因為那是最好的一種生活-—-Winifred-Gallagher" class="headerlink" title="我將過專注的生活，因為那是最好的一種生活 — Winifred Gallagher"></a>我將過<strong>專注</strong>的生活，因為那是<strong>最好的一種生活</strong> — Winifred Gallagher</h3><p><space><space></space></space></p><p><space><space></space></space></p><h2 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h2><p><strong>深度工作</strong> 在免於分心的專注狀態下進行職業活動。專注時，能把認知功能推向極限，產生他人無法模仿的價值。</p><p>第一部份(前100頁)寫了深度工作力為什麼重要的論證。像是專注的時候最開心、神經學、心理學、哲學的角度來看。很像 paper 中一直說自己好的部分。嗯 所以，等下這部分會跳過，不寫書摘… XD</p><p>第二部分以150頁的篇幅講如何培養深度工作力。其中提出了四個規則：</p><ol><li><strong>培養深度工作力</strong> <br> 介紹各種深度工作的模式，像是完全隔絕或是每天固定時間。介紹訣竅：開始前的儀式、挑選地點、協作、量化檢討和如何恢復有限的注意力。</li><li><strong>學會擁抱無聊</strong> <br> 介紹注意力的課題，如何透過擁抱無聊、對抗分心。介紹注意力的訓練，像是老羅斯福總統的注意力衝刺、冥想思考的秘訣和透過訓練記憶來增強注意力。</li><li><strong>拒絕任何好處心態</strong> <br> 使用工具(社群網路，email…)，會因為打擾而分心、減少深度工作力。這章教你怎麼選擇工具。</li><li><strong>排除淺薄事務</strong> 更多的策略。像是如何對付上司和無盡的電子郵件。</li></ol><h2 id="書摘"><a href="#書摘" class="headerlink" title="書摘"></a>書摘</h2><h3 id="Rule-1-培養深度工作力"><a href="#Rule-1-培養深度工作力" class="headerlink" title="Rule 1: 培養深度工作力"></a>Rule 1: 培養深度工作力</h3><p><strong>進入深度工作力的地下城</strong> 有幾種模式，第一種是完全隔絕與世隔絕。第二種是每月兩次、每次完全閉關兩三天。這兩種適合作家、藝術家、研究員那些可以人間蒸發、躲到<strong>地下城</strong>以一心憧憬支持自己的職業。後面兩種，適合一般人。</p><p>第三種是每天固定時段斷線躲起來，像是每天早上5點到7點，在沒人知曉的清晨做著不為人知的鍛鍊，曖曖內含光的一步一步變強。每天有深度工作就打個勾，透過延續勾勾的鍊子長度就能形成習慣，透過追逐著那可笑的鍊子長度… 漸漸會更容易進入專注工作的模式。最後一種是經過注意力訓練之後，一找到有空檔，每次一兩個小時閉關。強者是不用城堡的，只要夠強、強者在的地方就是城堡。</p><p>開始前要<strong>儀式</strong>，像榮格挑個神聖、神秘的<strong>地點</strong>，在世界的某個角落(この世界の片隅に)、像是有著精靈居住的森林湖畔、沒網路的小木屋、配上熱騰騰的<strong>拿鐵咖啡</strong>和能補滿SP能量的<strong>元氣牛肉漢堡</strong>、做七分半體操讓全身的細胞清醒來同步率120％、前一晚當然要睡飽。總之要找到<strong>適合自己</strong>發動變身的魔法詠唱。</p><p>必要時也可以用一些<strong>大動作</strong>，也就是挖坑讓自己跳、讓自己擁有背水一戰的專注力，像是花大錢買紐約東京來回機票，在上面飛行寫作。<strong>別獨自工作</strong>，某些工作透過同伴一起工作，可以形成白板效應，因為有回應的壓力，有時會更專心。像是 Pair-programming 和程序員鼓勵師(誤)。像企業一樣<strong>有紀律</strong>，排序找出重要的敵人(後衛魔法師)，做重要的事能更專注，因為對重要事務的渴望對分心有抗性。對目標，找出當下能做的動作，對它量化，專心在提升短程目標的效率。鎖定敵人後，一心在劍尖到敵人心臟的移動速度就好。利用計分板和定期檢討修正。</p><p>透過<strong>關機儀式</strong>，下班前先看完待辦清單，規劃好明天的工作。這樣回到地面時就不會因為想著深度地下城的工作不能好好休息。以關機儀式克服注意力殘留的「柴格尼效應」。作者下班前都會規劃好明天的工作，晚上就可以順利地恢復注意力的存量。</p><h3 id="Rule-2-學會擁抱無聊"><a href="#Rule-2-學會擁抱無聊" class="headerlink" title="Rule 2: 學會擁抱無聊"></a>Rule 2: 學會擁抱無聊</h3><p>意志力是一種<strong>有限</strong>的能量，越用會越少，但可以透過<strong>訓練增加</strong>總量、也能透過<strong>休息恢復</strong>。每次做決定或是忍耐抗拒不去做誘惑的事都會消耗注意力。透過計畫安排何時是<strong>分心時段</strong>，就不用每三分鐘都做一次決定「現在要不要去看動畫？」於是透過減少做決定的次數，減少抗拒所消耗的注意力。<strong>冥想</strong>是把注意力一直維持在同個地方，<strong>發現分心</strong>的時候要把他拉回同一個課題，注意有沒有在思考的迷宮中<strong>繞圈子</strong>，說著「人生的意義是什麼？什麼都做不到。不甘心啊 我真的是太弱了。現在要做什麼？人生的意義是什麼」，就這樣迷失在塔克拉瑪大沙漠中，要注意有沒有在冥想中繞圈子。另外透過冥想時對課題<strong>組織架構</strong>，畫迷宮地圖、像是「要到最下層打王，所以要找到樓梯或縱穴、要先找到鑰匙通過往西邊的閘門，尋找紀錄點和安全樓層。」，這樣冥想在腦袋組織架構之後，能更專注地到達更深層的迷宮。另外像老羅斯福總統一樣，每次衝刺時都<strong>超過自己的極限一點點</strong>，這樣來鍛鍊自己升級最快。 <strong>訓練記憶力</strong>等同於訓練想像力讓自己能更專注，可以透過練習在心中想像的能力，加強下次在迷宮中深度工作的反應速度。</p><h3 id="Rule-3：-拒絕任何好處心態"><a href="#Rule-3：-拒絕任何好處心態" class="headerlink" title="Rule 3： 拒絕任何好處心態"></a>Rule 3： 拒絕任何好處心態</h3><p>一把刀的特性有攻擊力、速度、魔法攻擊力、耐久，有時還會帶有詛咒。每個迷宮有不同怪物，要選適合的武器的方法就是換換武器，然後去砍砍敵人，看順不順手。不要看攻擊力高就用，要<strong>綜合考量</strong>這個工具適不適合目前的<strong>主要敵人</strong>(短程目標)。臉書、IG、Email 請選擇性地使用，用<strong>斷線實驗</strong>、列出好處與壞處一起考量，才決定下次遠征要帶什麽武器。安排工作以外的時間，盡量不要利用網路來娛樂自己，因為網路上很多訊息都是被強大的設計師和行銷人員精心用黑魔法，把無意義的東西，包裝成的精美產品。像是網路文章的標題，「千年一遇的女優 — ~!@#$%」，都是吸引你有限注意力的寶箱，但打開卻空無一物。要先規劃更有品質的娛樂，讓下班後的時間更有意義。</p><h3 id="Rule-4：排除淺薄事務"><a href="#Rule-4：排除淺薄事務" class="headerlink" title="Rule 4：排除淺薄事務"></a>Rule 4：排除淺薄事務</h3><p>人總有一些雜事要做，而不得不分心的情況。這章介紹如何讓這些情況減到最少。安排工作中的每一分鐘，並預留預備時間，這樣一整天就不會一直想著接下來要做什麼而分心。把工作做分類，有深度和淺薄的，先分類好，決策時就不會花費注意力。跟上司主管談一談，確保深度工作力的時間比例，上面不同意就離職… Orz 和外部合作時，主導並最佳化聯絡過程，減少聯絡次數。想要最快速升級，就要最大化在地下城的時間，當個邊緣人、難搞的人、進入神之領域的棋手，在有限的人生裡，做一些真正重要的事吧。我要看著アイズ・ヴァレンシュタイン的背影變強 啊啊啊啊～～</p><h2 id="註解"><a href="#註解" class="headerlink" title="註解"></a>註解</h2><ul><li><strong>地下城</strong>：進入深度工作力模式</li><li><strong>怪物、敵人</strong>：工作的目標</li><li><strong>武器</strong>：工具</li><li><strong>地面</strong>：地面上沒有怪物，比喻工作之外的時間</li><li><strong>程序鼓勵員</strong>： 不工作的女性員工，但其存在能提升周遭男性工程師的工作能力</li><li><strong>元氣牛肉堡</strong>：摩斯漢堡在早餐時段販售的食品、配冰紅茶的套餐價格為85元</li><li><strong>王</strong>：終級的工作目標</li><li><strong>柴格尼效應</strong>：因為想著前面未完成的工作，注意力殘留在前面的工作，造成當前工作注意力不專注。</li><li><strong>アイズ・ヴァレンシュタイン</strong>： 某地下城主題輕小說的女主角</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;space&gt;&lt;space&gt;&lt;/space&gt;&lt;/space&gt;&lt;/p&gt;
&lt;p&gt;&lt;space&gt;&lt;space&gt;&lt;/space&gt;&lt;/space&gt;&lt;/p&gt;
&lt;h3 id=&quot;我將過專注的生活，因為那是最好的一種生活-—-Winifred-Gallagher&quot;&gt;&lt;a href=&quot;#我將過
      
    
    </summary>
    
    
      <category term="ACGN" scheme="http://wangchou.github.io/tags/ACGN/"/>
    
      <category term="生產力" scheme="http://wangchou.github.io/tags/%E7%94%9F%E7%94%A2%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>新海誠展 十五年的動畫歷程</title>
    <link href="http://wangchou.github.io/2017/12/26/%E6%96%B0%E6%B5%B7%E8%AA%A0%E5%B1%95-%E5%8D%81%E4%BA%94%E5%B9%B4%E5%8B%95%E7%95%AB%E6%AD%B7%E7%A8%8B/"/>
    <id>http://wangchou.github.io/2017/12/26/新海誠展-十五年動畫歷程/</id>
    <published>2017-12-26T08:22:00.000Z</published>
    <updated>2017-12-27T07:16:36.722Z</updated>
    
    <content type="html"><![CDATA[<p>在新加坡看了「你的名字」、在東京看了「言葉之庭」，在日本最常去的地方就是動畫中常出現的「新宿御苑」、看著你的名字中瀧的高中、烏鴉飛過的 NTT DoCoMo 代代木大廈; 總有人的言葉之庭、大概是因為我總是在晴天的時候去。坐一小時的電車，尋找樹陰、鋪上唐吉軻德買的廉價野餐墊、看書、看幼稚園的校外教學，有時還會繞去人少的千馱谷門，逛逛將棋會館。好想買新宿御苑的年間PASS… 扯遠了。</p><p><strong>新海誠</strong> 1973年長野縣出生。是零下十幾度在湖上滑冰看日出、擁有70萬日元電腦的小朋友。國、高中參加過排球部和弓道部，接著跑到東京唸文學系、是建築世家的預定接班人。但他拒絕接班，跟老爸說年輕時有想做的事。1996年大學畢業後，就跑去遊戲公司 (Falcom) 做了五年，有名的「英雄傳說系列的 III - V代」他都有參與、主攻美術、動畫、設定之類的。還記得三代的白髮魔女傳好好玩～ 就這樣過著早上6點上班、晚上12點下班的爆肝人生。社畜和「大東京玩具箱」都是真的啊…</p><p>在 Falcom 第五年時, 他就像村上春樹每天經營的酒吧關門之後，深夜寫寫小說一樣。新海誠12點下班之後開始做動畫「星之聲」到凌晨3點，兩個人都是下班後心中還有創作的渴望，或是說有了再累都不能放棄的夢想，然後才讓這個夢想成真。不過星之聲做一半，他就離職啦～ 閉關工作八個月。結果兩個人各自在29歲生出的作品，都得了獎。正式轉行～</p><p>他自幹了一次監督、美術、腳本、作畫… 全包25分鐘的長動畫、太累了，明白了自己適合哪一部分、不適合哪部分，就開始找人一起做了。後來的幾部動畫，「雲之彼端，約定的地方」、「秒速五公分」、「追逐繁星的孩子」、「言葉之庭」和「你的名字」都是和很多人合作的作品，他主要負責原作、腳本、監督。日本文學系、兒童文學繪本社團出生的他，還有寫動畫電影的小說。順帶一提，他在夏天有慢跑習慣、在最近的問答中說現在自己「工作時絕對不熬夜」，每天能專注多久才工作多久。</p><p><strong>新海誠展</strong> 在華山展的內容有從「星之聲」到「你的名字」的動畫製作過程。展場內可以拍照但不能錄影。從文字企劃、分鏡腳本，到人物、場景設定的設定圖像、作畫與修正、合成分鏡圖動畫。都有展出。門票300元。</p><h3 id="動畫製作過程以你的名字舉例"><a href="#動畫製作過程以你的名字舉例" class="headerlink" title="動畫製作過程以你的名字舉例"></a>動畫製作過程以你的名字舉例</h3><h4 id="企劃-gt-分鏡腳本-gt-分鏡腳本動畫-gt-人物、場景設定-gt-原畫"><a href="#企劃-gt-分鏡腳本-gt-分鏡腳本動畫-gt-人物、場景設定-gt-原畫" class="headerlink" title="企劃-&gt;分鏡腳本-&gt;分鏡腳本動畫-&gt;人物、場景設定-&gt;原畫"></a>企劃-&gt;分鏡腳本-&gt;分鏡腳本動畫-&gt;人物、場景設定-&gt;原畫</h4><ol><li><strong>企劃 (新海誠)</strong><ul><li>概要 (700字)</li><li>故事背景、場景、道具設定 (400字)</li><li>為什麼現在要拍這個故事 (1000字)<br><img src="/img/shinhai/1.jpeg" width="360"><br><img src="/img/shinhai/2.jpeg" width="360"><br><img src="/img/shinhai/3.jpeg" width="360"></li></ul></li><li><strong>分鏡腳本 (新海誠)</strong><ul><li>分鏡、動作、對話、時間</li><li>分鏡會含畫面走向、人物要加上陰影部分</li><li>分鏡動畫，1700張分鏡、四秒一張 (你的名字藍光有附完整的分鏡影片、新海誠親自配音)<br><img src="/img/shinhai/4.jpeg" width="360"><br><img src="/img/shinhai/5_1.jpeg" width="360"></li></ul></li><li><strong>角色設定、場景設定 (人設：虎與龍、未聞花名的「田中將賀」)</strong><ul><li>以女主角宮水三葉為例、會有人物的各種角度、長髮短髮、陰影的設定</li><li>另外還會有人物身上的顏色的設計規範</li><li>場景會有遠中近 (系手町、神社附近、三葉的房間)</li><li>每個房間都有設計師先想像好、畫好才開始作畫<br><img src="/img/shinhai/5.jpeg" width="360"><br><img src="/img/shinhai/6.jpeg" width="360"><br><img src="/img/shinhai/7.jpeg" width="360"><br><img src="/img/shinhai/8.jpeg" width="360"><br><img src="/img/shinhai/9.jpeg" width="360"></li></ul></li><li><strong>作畫 (作畫監督：神隱少女的「安藤雅司」)</strong><ul><li>原畫師對著分鏡腳本畫原畫 (Key Animation)</li><li>動畫師補上原畫間的中間影格<br><img src="/img/shinhai/10.jpeg" width="360"><br><img src="/img/shinhai/12.jpeg" width="360"></li></ul></li><li><strong>其他</strong><ul><li>音樂、音響、配音、聲優…</li></ul></li></ol><h3 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h3><p>展覽中展出每部動畫製作時的部分的企劃、分鏡腳本、人設、原話，可以讓人好好學習如何做一部動畫、寫一個故事。想像，從2014年2000字的文字企劃「若之是夢」怎麼變成2016年100多分鐘的「你的名字」。文字企劃的時候，強調的是靈魂交換、連結(結び)。但沒有提到記憶相關、「你的名字」遺忘的主題。動畫腳本到真正電影之間也省略了不少部分。也不知道在這個企劃，贏了多少胎死腹中的企劃。還有從早期作品到最新的你的名字間的作為一個監督、腳本的成長，這些點都是值得思考玩味的地方。</p><p>2016年43歲的新海誠不一樣了。他已結婚、還有一個7歲的女兒。10年前，他做「秒速５公分」時是單身、還做成人遊戲公司(minori)的動畫、會一個人去倫敦遊學一年。現在和那時自由自在孤獨的樣子不同了。他也說311地震之後，日本人需要的東西也不一樣、想做的東西也不一樣。期待他下一部會做怎樣的動畫，希望在大紅大紫之後還他能保有原來的色彩。</p><ul><li>PS:<ul><li>會日文的朋友推薦買展場的書 (200多頁、1000元)，書裡有所有展出作品的靜態部分、分鏡腳本、原畫、作品分析等。</li><li>想深入了解動畫產業，強烈建議看 2015年出品、IMDB 8.2 分的動畫「白箱」。</li><li>想了解分鏡腳本、漫畫產業，推薦看「爆漫王」。</li></ul></li></ul><h3 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h3><ul><li><a href="https://ja.wikipedia.org/wiki/新海誠" target="_blank" rel="noopener">新海誠日文wiki</a></li><li><a href="http://www.kiminona.com/#interview_ando" target="_blank" rel="noopener">映画『君の名は。』公式サイト</a></li><li><a href="https://www.gigcasa.com/articles/471452" target="_blank" rel="noopener">新海誠｜人就是這樣，必須習慣失去</a></li><li><a href="https://www.nippon.com/hk/people/e00107/" target="_blank" rel="noopener">新海誠導演的世界：渺小的個人與浩瀚的宇宙之關聯</a></li><li><a href="http://hkacger.com/archives/30624" target="_blank" rel="noopener">【我用青春換此生】新海誠父親，百年建築公司「新津組」社長談自己兒子新海誠！</a></li><li><a href="https://read01.com/2DANER.html#.WkIJFiOKXOR" target="_blank" rel="noopener">新海誠來中國，聊了聊動畫《你的名字》背後的故事</a></li><li><a href="https://read01.com/ERK2R2.html#.WkIJNSOKXOR" target="_blank" rel="noopener">新海誠究竟是個怎樣的人</a></li><li><a href="https://read01.com/QRGaMA.html#.WkIJTSOKXOR" target="_blank" rel="noopener">新海誠：十四年，專注製造少女心</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在新加坡看了「你的名字」、在東京看了「言葉之庭」，在日本最常去的地方就是動畫中常出現的「新宿御苑」、看著你的名字中瀧的高中、烏鴉飛過的 NTT DoCoMo 代代木大廈; 總有人的言葉之庭、大概是因為我總是在晴天的時候去。坐一小時的電車，尋找樹陰、鋪上唐吉軻德買的廉價野餐墊
      
    
    </summary>
    
    
      <category term="ACGN" scheme="http://wangchou.github.io/tags/ACGN/"/>
    
  </entry>
  
  <entry>
    <title>Redux 簡介：我終於看穿它了</title>
    <link href="http://wangchou.github.io/2016/11/06/Redux-%E7%B0%A1%E4%BB%8B%EF%BC%9A%E6%88%91%E7%B5%82%E6%96%BC%E7%9C%8B%E7%A9%BF%E5%AE%83%E4%BA%86/"/>
    <id>http://wangchou.github.io/2016/11/06/Redux-簡介：我終於看穿它了/</id>
    <published>2016-11-06T08:41:00.000Z</published>
    <updated>2017-12-27T02:51:36.353Z</updated>
    
    <content type="html"><![CDATA[<p>Redux 把資料放在 store 中，它是個資料庫，但 Redux 不用常見的 SQL 介面，要開發者自訂指令介面。這介面有簡單的標準，他只接受 Action = {type, payload} 物件的輸入。在傳統的資料庫中，下了 SQL 資料庫就會照指令，來更新資料庫，但在 Redux 中，開發者需要自行寫一個 Reducer 來處理輸入的 Action 指令。和傳統資料庫不同的是，這個 Redux 資料庫變了之後，Redux 會 push 變動了的資料到訂閱者 (一個 Javascript 物件)，行為就像是 Baas 服務 (parse, firebase) 常見的 push message。Redux 和傳統關聯式資料庫最大的不同點是，Redux 用 JS 物件或變數來儲存資料；傳統資料庫因為有大量相關的資料，所以用資料表 (data array, data table) 來儲存。這讓 Redux 的狀態樹一直呈現很難視覺化的情況，目前樹狀結構最好的視覺化就是，Browser 的 dev tool 了。如果能把 Redux state 架構轉成 html，也許會有很好的效果也不一定。 另一個選項是 D3.js 的 Simple Tree。</p><h1 id="簡單的資料庫列表比較"><a href="#簡單的資料庫列表比較" class="headerlink" title="簡單的資料庫列表比較"></a>簡單的資料庫列表比較</h1><p><img src="https://4.bp.blogspot.com/-sSMTas7I6yk/WB7sjh1ylYI/AAAAAAAA45k/E5kCkDcf1F0ZYe-Xf4Yv4KGeIfnnowtUwCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.37.19%2BPM.jpg" alt=""></p><p>Redux 和 Firebase 的資料儲存方式很相近，可以很好的一起運用整合。也許進一步把 client 的資料再切為，Server Data 和 View Data 的設定會更好。Server Data will always synced with Firebase.</p><p>另外一提，Redux 實際上就只是個資料庫 (Model)，只有 input &amp; outpt，哪有什麼 middleware… in the middle of what？Redux-middleware 實際上是一部分的 controller，跟 Redux 無關啊。React 也包含 Controller。畫成圖來表示<br><img src="https://3.bp.blogspot.com/-iuJOF3G-YCg/WB7sNkMUYfI/AAAAAAAA45g/-T3GLN0twVwBwHN2hm9_ncod0-qlG4krQCLcB/s1600/Screen%2BShot%2B2016-11-06%2Bat%2B4.38.55%2BPM.jpg" alt=""></p><p>Flux 把傳統的 MVC 切成了上行和下行，形成了一個循環資料流，它最大的優點是有 paper 支持的 Single Source of Truth。想像一下 bug 在房間亂跑好抓還是… bug 繞著固定的圈圈跑，bug 繞圈圈跑的話，在原地等 bug 跑過來就抓到了。</p><p>總結一下，說穿了 Redux 就是一個啥功能都沒有的資料庫設計規範。也因此，他的文件很長、相關模組很多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Redux 把資料放在 store 中，它是個資料庫，但 Redux 不用常見的 SQL 介面，要開發者自訂指令介面。這介面有簡單的標準，他只接受 Action = {type, payload} 物件的輸入。在傳統的資料庫中，下了 SQL 資料庫就會照指令，來更新資料庫，
      
    
    </summary>
    
    
      <category term="firebase" scheme="http://wangchou.github.io/tags/firebase/"/>
    
      <category term="redux" scheme="http://wangchou.github.io/tags/redux/"/>
    
      <category term="MobX" scheme="http://wangchou.github.io/tags/MobX/"/>
    
  </entry>
  
  <entry>
    <title>見樹又見林 - 書摘 &amp; 心得</title>
    <link href="http://wangchou.github.io/2016/07/23/%E8%A6%8B%E6%A8%B9%E5%8F%88%E8%A6%8B%E6%9E%97-%E6%9B%B8%E6%91%98-%E5%BF%83%E5%BE%97/"/>
    <id>http://wangchou.github.io/2016/07/23/見樹又見林-書摘-心得/</id>
    <published>2016-07-23T01:01:00.000Z</published>
    <updated>2017-12-27T02:53:45.289Z</updated>
    
    <content type="html"><![CDATA[<h3 id="書摘的摘要"><a href="#書摘的摘要" class="headerlink" title="書摘的摘要"></a>書摘的摘要</h3><p>社會學是一種讓你看到社會現象背後，整體樣貌的工具，看清楚後就可以尋求一點一滴的改變方法。</p><p>用個人主義的方式理解世界，將無法理解社會現象。</p><p>社會學中有很多概念工具。社會體系中有文化與結構。社會文化中有符號、信念、價值觀、規範、物質環境。社會結構中有角色、與角色的關係與資源分配。</p><p>「社會文化」是社會學中的一個概念工具。文化中的「符號/概念」限制了你對現實世界的理解，我們處於文化中只能透過符號/概念在心中建構出來的真實理解，如果文化中沒有這概念，就無法理解。文化中的「信念、價值觀與規範」，是人判斷哪個選擇比較好、做或不做的依歸，形塑了社會體系中每個角色最小阻力的路。文化中的「物質環境」，像是電視機、手機、農業、工業社會，都會被文化影響、也會影響文化。人常忘了自己的文化只是眾多文化的一種，透過意識到文化盒子的存在，人可以看到自己社會體系的侷限、也可以想像在不同社會體系的世界會怎樣。</p><p>「社會結構」是社會學中的另一個概念工具。角色有天生的像是性別、後天的像是職業和情境式的像是行人。人同時會參與多個社會體系，在每個社會體系中扮演一個以上的角色。透過角色關係，每個角色有他的權力與限制，有他阻力最小的路。角色位置和佔據角色位置的人是兩個不同的概念，扮演這個角色的人可以決定要不要，這個角色在社會中被期待的方式走。所以理解一個人的行為時要，理解是結構性的原因，還是個人的選擇。每個社會體系會賦予每個「角色位置」，想要的內容(ex: 資本社會：財富)，和獲得這些內容的合法機會。如果想要的和機會相差太大，這個角色就會容易陷入困境，而對社會體系有四種偏差行為，創新、反叛、退縮與脫離。</p><p>人透過行動參與社會體系，社會體系改變現實中的物質環境，物質環境影響人，形成一個循環、這就是人類的生態學。</p><p>自我和其他文化中的概念一樣，只是一個被文化符號建構出來的真實。我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。</p><p>社會體系就像一齣電視劇，劇本為文化、場景為物質世界、角色為社會體系中的身份。我們就是其中的演員，大多數人從個人主義的視角看世界，忘了我們可以透過挑劇本、挑角色。如果沒有意識到社會體系的盒子，就只能一直演同個劇本、同個角色，嗯 你的演員人生入戲太深就這樣子了。自己現在的劇本、現在的角色是什麼呢？現在扮演的角色、社會體系真的存在嗎？有其他人也參與這個你想像中的社會體系嗎？還是只是你自己以為而已。透過理解社會學去理解你生活中的劇本，好好演出你的人生、改變其他人的人生。</p><p>第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。</p><h3 id="本書介紹-p1-p7"><a href="#本書介紹-p1-p7" class="headerlink" title="本書介紹 p1~p7"></a>本書介紹 p1~p7</h3><p>社會學存在的理由是我們身處的社會中總有一些無所謂的苦難的現象。碰到這個時候，我們會問：「為什麼會這樣？」這時社會學成為找到這問題答案的一個工具，幫助我們理解事情如何相互牽連，看清楚後，也就能尋求一點一滴的改變方法。社會學無法讓你全盤理解整個世界，但可以思辨如何參與在生活中的環境，像是社區、家庭和公司。</p><p>社會學提供的是一種有系統的思考方式。實踐社會學，使得我們觀察、思索、理解這個世界，改變這個我們身處其中的世界。社會學中有很多理論，都由社會學的本質核心觀念而來。這本書不介紹一大堆理論和專有名詞，但會介紹這個核心觀念，讓人能從社會學的角度來看這個世界。</p><h3 id="第一章-森林、樹群，還有那件事-p8-p42"><a href="#第一章-森林、樹群，還有那件事-p8-p42" class="headerlink" title="第一章 - 森林、樹群，還有那件事 p8~p42"></a>第一章 - 森林、樹群，還有那件事 p8~p42</h3><p>多元的社會中的差異會形成特權的基礎，不平等持續的現象，是因為大家都不願意討論特權。因為討論時，享有特權的人會覺得自己被攻擊、沒有特權的人害怕可能會被報復所以不討論。「享有特權的人討論時覺得自己被攻擊」的原因是他們用個人主義的方式看世界，這看法在美國尤其普遍。個人主義的問題是他們忽略了社會中的現象，除了每個個人之外也受社會中的各種關係影響。社會學要研究森林、樹、樹與樹之間的關係。我們叫我們參與的那廣大一點的世界「社會體系」。家庭、公司都是社會體系的一種。社會體系中的角色不等於佔據那個角色的人，個人主義的角度無法理解這點，所以當我們在討論特權「角色」時，他們會以為我們在攻擊「佔據這個角色的個人」。我們必須理解社會體系不同於我，我也不是社會體系本身。</p><p>社會體系中會有社會規則，形成每個人面對到最小阻力的路。如果只把社會體系的這些規則當作權威，當成人外在的系統，忘了人是社會體系的一部份、社會規則運作需要人配合，就會忘記自己是可以改變社會體系的。</p><p>人參與社會體系會發生什麼事取決於系統本身和運作規則、人在其中的作為。體系影響參與者的想法、感受和行為，靠著就是鋪陳出這些阻力最小的路，雖然任何時刻參與其中的人都有無限多種事可做，但我們通常都不這麼想，只看到體系中很有限的幾個可能性。人也許會同時參與多個體系，然後不同體系中最小阻力的路互相衝突，讓人覺得進退兩難，社會學叫這種情況「角色衝突」</p><p>個人主義對理解社會現象沒有用，因為他只看到人、沒看到社會體系。個人主義沒法解釋，不同社會間同個現象個人的差異(ex: 自殺率)。社會學會問「在 xxx 社會體系中，yyy 會覺得做 zzz 是最小阻力的路的原因是什麼？」靠這個問題來探究比自己範圍更大一點的外在情境。但要注意，我們無法只看人，就理解體系的運作；我們也無法只看體系的運作，就理解人的一舉一動。個人主義的人常會問：「是怎樣的人會做出如此殘暴的事？」。把社會現象簡化為「什麼樣的人」的緣由，忽略這些人所身處的社會體系。</p><p>在社會體系中總是會和最小阻力的路有所牽連，因為即使你不照社會規則走，其他人會照社會規則來對待你。</p><p>社會現象，和參與人有關、又跟他們無關。無關是因為並不是他們創造出這個種族歧視的社會。有關是因為，對於如何參與這種族歧視的社會，人總是還有一些選擇。</p><p>那社會中的人該如何呢？透過社會學我們可以知道，不用為社會問題感到自責，因為這不是我的錯。社會學也讓人了解到如何透過參與這個社會，讓我做的選擇如何影響這個社會體系。</p><p>個人式的解決之道，無法處理社會問題。社會學對改變社會，比起個人式採用更為複雜的模型，同時著眼社會生活的不同層次。透過體系的層次、個人的層次一起看社會問題。</p><p>社會體系影響人，人的行為影響社會體系的運作，就這樣不停循環著。每個人對同個社會體系的理解的、對同個社會體系的心理模型也不同，理解每個人的想法、理解每個體系。這就是社會學要研究的事。</p><p>簡單說：實踐社會學會問兩個問題，「人們參與之中的是什麼？」「人們又如何參與？」兩個問題相互碰撞。本書比較著重第一個問題，對於社會體系的分析。</p><h3 id="第二章-文化-—-符號、觀念和生活的種種-p43-p95"><a href="#第二章-文化-—-符號、觀念和生活的種種-p43-p95" class="headerlink" title="第二章 - 文化 — 符號、觀念和生活的種種 p43~p95"></a>第二章 - 文化 — 符號、觀念和生活的種種 p43~p95</h3><p>人透過詞彙/符號，把感官經驗在心中重新建構一個真實。然後在這個詞彙建構真實的基礎上思考、判斷、做出行為。然而人沒有意識到在心中建構真實時，人也正在選擇。這選擇是一個創造性描述的過程(像是翻譯)，選擇詞彙的同時也就建構出了新的真實。</p><p>詞彙從哪裡來？答案是，我所參與的社會是有文化的，那文化主要包含符號，特別是語言中的詞彙和各種想法。文化同時是物質的，像是社會生活中的「東西」、也是非物質性的，透過符號和想法來思考並且賦予任何事物意義。</p><p>當我們命名一個感官上的東西，例如「雷聲」，在最簡單的意義下，我們藉著對它的感受，創造了與它的關係。如果沒有命名，我們不會注意到它、會被人有限的注意力忽略。我們的注意力只能集中在一小部分上，唯有透過符號命名，我們才能把注意力集中在這些事物上，我們才能建構一個真實。蘇珊.朗格：『用符號去建構真實，是人類之所以能成為人類最重要的關鍵』</p><p>(os: 世界的大小由想像的範圍決定。符號像是 support vector/basis 界定了世界的邊界，用符號把真實投影在心中世界。)</p><p>語言可以建構各式各樣的真實，包括我們沒有感官經驗的真實。像是我們不能聽到、聞到或觸摸到所謂的愛。我們看到他人的行為，但行為本身不是愛，而是我們把它想成：「這行為意味著這個人愛我們。」像是大多數人沒能直接觀察到的「原子」，光是透過語言文字就足夠建構出我們視為的現實。在這個意義下，符號的力量遠遠超過它標示的東西。</p><p>對於同一件事人有不同的理解版本。每個人心中對於每個符號的意義有不同理解。</p><p>每個文化的第一個目的，是提供一種人們可以辨識什麼是真的，什麼是假的方法，這是所謂的信念。在某一意義下，符號是最簡單的信仰陳述，字典的每一個定義就是宣稱某些東西是真實存在的。當文化定義某些是真的，不管實際上是真的還是假的，都會有真實的後果。稱為「顯而易見」的，卻未必是真的，只是在某一特定文化中，被預設為無需懷疑的。(文化中大家都當真的事物…)</p><p>文化中有價值觀。價值滲透到我們生活的每個層面，因為種種價值為我們提供一個方法，以便在很多看起來都相似的事物間做選擇。價值除了影響我們怎麼選擇行動的路線之外，還影響我們怎麼看待、對待我們自己和別人。人常忘了，我們把價值當成真實本身自然而然的一部份，而不把它當成是「關於」社會如何建構真實的想法。除了人的基因中的基本偏好，大多數的偏好是來自於在某一特定文化中經由「社會化」所學來的價值。社會體系的組織方式，決定了價值的選擇。經驗過越多文化，我越意識到自己的文化只是一個文化而已，也看到自己總是從文化所提供的有限可能中選擇。</p><p>作為個人，我可以意識到文化實質存在，並且形塑我們的觀點和經驗，包括我認為我要的是什麼。我唯有藉著把我自己從我身處的文化所提供的狹隘選擇範圍解放出來，才能擴大我的「自由」。要達到這目的，我需要「跨越出」我習慣的文化框架，這樣才能看到我處的文化「框架」，其實只是很多可能的一種。</p><p>價值就像是語法原則，我們用它來解釋從未見過的句子。至於我們怎麼應用那些原則，完全看我們自己。文化中的價值有時會被轉換成規範(norm)，以獎勵和懲罰的「社會後果」來要求人們遵守。若能改變他所參與的「社會體系」，在不同文化規範下就能改變他行動的社會後果。</p><p>為什麼要有規範？功能學派認為每個社會體系都有一些要求，在達到這些要求之後社會體系才能運作。如果沒有規範，社會之中的關係就會被瓦解。這關係主要包含我們對彼此的期望。規範對於界定體系的疆界也很重要，規範告訴我們區別自己人與其他人。最能獲得社群的接受並能形成影響的方法是，從一開始就接受這社群的文化。拒絕接受的話，這文化就不會接受你。</p><p>文化觀念對人們來說是在體系中應該有怎樣的角色。小孩子玩在一起一定要成立「一國」，第一件事是訂定規則，服從的人才能加入。規則本身是什麼不重要，重要的是建立一種比較大的東西，使成員感覺自己是其中一員，同時也讓成員藉此知道自己是誰。法國社會大師涂爾幹把這種集體感覺的「我們」，當成社會生活的基礎，這是唯一可以控制人們行為的方式。這就是道德，體系中一種共同分享的感覺。沒有這集體感覺，人們會失落，社會體系會瓦解。</p><p>所有規範都帶有歸屬和認定的色彩。如果道德是屬於歸屬的問題，那些被視為外人的人，會被當成違反道德準則的偏差者對待，不是因為他們做了什麼，而是因為他們就是他們。在不同形式的社會不平等和壓迫中，這扮演關鍵的角色。</p><p>功能學派的學派的觀點是有了規範社會才能運作。但這個觀點沒法看到的是：規範可以排除和壓迫社會上某些人。我們很難理解為什麼一個需要有這樣的安排，讓其中有些團體取得優勢，而讓其他成員承受痛苦。(價值的方向性？)</p><p>從社會學的衝突觀點來看，比較能理解社會中存在的有系統的排擠、剝削、宰制和濫權。優勢團體會藉著自己的權利和影響去形塑文化以利於自己的利益；包括保護自己的特權。資本主義中有資本的人有權力，他們會形塑一個文化來保護有資本的人，所以在文化中特別強調不是每個文化中有的「私有財產」的概念。價值為影響別種價值，所以看起來只是保護財產的規範，也可能維護者以特權和不平等為基礎的社會秩序。社會生活的每個面向就是：我們在容易直接了解當地看到的連結關係，其實只是冰山一角。整體理解是社會學實踐很重要的面向，能帶我們深入表層，發覺背後關係的連結。</p><p>文化的態度：文化作為感覺。信念、價值觀和規範，對我們如何認識真實，如何思考真實，言行舉止該如何，有很大的影響。他們使我們對人們(ex: 同性戀)有某些感覺。對在這文化中，這類被辨識出來的角色，社會對他們的期待是什麼，有沒有合乎社會要求。這態度主要是感情的(情緒來自大腦邊緣系統的辨識)，也就是說你所感受到的情緒，沒經過大腦思考(前額葉)，就直接受到你所認同的文化態度直接影響。感情、信念和價值的混合體正式文化態度的核心。</p><p>我們建構的真實是非物質的，也是物質的。物質文化之所以存在，是因為人有改變世界的能力。同時也改變了文化、改變了自己。是人改變物質世界、物質世界改變文化、文化改變人的循環。例如，紙張和印刷術的出現，讓社會團體想透過控制它，來控制訊息的傳遞。以前一段時間，要有良民證才能擁有一部打字機。資本主義下越來越有一個趨勢，那就是出版社隸屬於，一個與出版毫無關係的大財團下，以便對觀點的流通進行社會控制。</p><p>一個穩定的社會文化，一定有其存在的原因，相較於其他文化的優勢、特權，能從文化競爭中搶到更多資源。</p><p>社會控制的問題和印刷機器或電視攝影機之類的物質文化的存在與否關係較少，而是和這類物質文化在某一體系中的運用有關。如果我們忽略了物質本身和使用物質的方式，這兩者之間的不同，那我們進一步就會賦予物質文化自己的生命，以為物質文化可以完全支配我們。就像社會體系中角色和佔據角色的人的差別，物質文化中的東西和使用東西的人，是兩個不同的概念。</p><p>物質文化是社會文化的一個重要的部分，對於社會一樣。人也常忘了意識到自己所處的物質文化，也只是眾多物質文化其中之一。人是可以改變物質文化的。</p><p>我們太容易忘記，文化的總體其實是人類豐富潛能想像的產品。哲學家蘇姍朗格寫道：「我們活在觀念的網絡中，編織網絡的纖維是我們自己創造出來的。」我們就好像住在一個由文化建構的小盒子中，不論是在家庭中、在工作場所中，或是社會中都是如此。我們的視野很少能夠超越小盒子，主要的原因是… 我們連這小盒子的存在都不知道。住在盒子裡，我們看不到外面，就以為自己的文化是最好的、是唯一的文化，這就稱為「種族中心主義」。只有意識到盒子的本身，其他可能性才會開啟。</p><p>在複雜社會中，主宰的團體往往用他們建構真實的文化觀念去應用到其他人身上。</p><p>文化可以同時引導我們往兩個方向看。文化可以讓我們往內看，看到我們特殊的文化盒子的有限空間。也可以指向盒子本身，引導我們去想像：我們同時在盒子的裡面和外面。這是個充滿能量的經驗。</p><h3 id="第三章-社會生活的結構-p99-p147"><a href="#第三章-社會生活的結構-p99-p147" class="headerlink" title="第三章 - 社會生活的結構 p99~p147"></a>第三章 - 社會生活的結構 p99~p147</h3><p>和文化一樣，社會結構的概念是一個社會學實踐的重要關鍵，因為它相當程度地決定了社會生活最令人熟悉而且可預期的樣貌。文化概念形塑的我們如何思考、如何感受。結構則將這些文化概念統整到各種連結人與人、人與體系、體系與體系之間的社會關係。</p><p>當我們在生活中經歷了某些戲劇化的變化時，我們會覺得迷失，這是因對我們在一個或多個社會體系中的結構位置改變了。自己的社會位置是什麼，這個問題意味著「我是誰、能做什麼、該做什麼、意義及目標是什麼」。找不到位置的話，也失去了定位體系，這時候我們就會感受到迷失。</p><p>社會結構有兩層意義：第一層意義是關於社會生活各層面中的社會關係是如何安排。第二層意義，社會結構指的是社會體系中各種資源的分配。分配包含每個角色的資源和權力，以及人們在角色位置的分配。</p><p>一個人的「身份地位」就是一個人在體系中所佔據的結構位置；而我們「參與」一個體系的意思就是我們在這個體系中佔據了一個以上的身份地位。在這裡「身份地位」既是位置，也是佔據這個位置的人。請注意這兩者之間的差異，任何人都可以佔據這個身份位置，不管有沒有人佔據，這個身份位置都會存在。</p><p>這種「身份位置」與「佔據此身份位置之個人」之間的區分，對於理解社會生活如何運作有關鍵的意義。如果我們混淆了這兩者的話，我們很可能會犯了企圖用個人因素來解釋社會結構現象的錯誤。</p><p>總統他們只是坐在這個位置上的人。沒有任何一個位置只賦予在位者權利而不同時加諸各種限制的；他們所居的職位和一個巨大的職位結構連在一起，這個結構不僅只有政府內部、也有政府之外的一些位置。這些關係正是限制了總統能做什麼、不能做什麼的因素。</p><p>更複雜的事，我們同時身處於各種體系之中，這表示我們同時具有許多不同的身份。有些身份是我們與生俱來的，像種族、性別、家庭中的身份。有些身份則是我們在人生過程中獲得的：學生、工人、職員、導師、伴侶、博士。不管是先天或後天獲得的身份，也不論我們是不是真的在執行、實踐這些身份，我們都「具有」這些身份。這些「身份」如影隨形，不管是我們自己或是別人，都用這些身份來認識我們。</p><p>還有一些身份是不會隨時跟著我們的，因為他們只存在特定情境之中，像是行人、巴士乘客。情境式的身份必須不斷實踐才能維持，只和我在哪裡、當時在做些什麼事有關。</p><p>佔有某個位置的身份意義是：它讓我們和各個社會體系產生關連，提供了我們經歷、參與這些體系時，一條阻力最小的路。身份提供了一整套的文化概念，這就是我們所稱的「角色」，它會在角色所有人和角色關係人身上加諸全套的信念、價值、態度與規範。</p><p>當一個人的數個角色的價值有所牴觸時，我們稱為角色衝突。像是教授和異性學生的關係，教授會有「老師」和「情人」這兩種角色。從一個結構的觀點來看，老師和學生的性關係是不可能平等的，因為那些決定了他們在體系中的角色，本質上就是不平等的，也沒有辦法被拉平。只要是老師就必然擁有些權力。由於師生戀這種結構角色所會引起的龐大衝突，一個健康的師生戀關係的機率是微乎其微的。這也是為什麼學校和企業都不鼓勵，或明令禁止類似師生戀這種涉及結構權力關係的親密關係。</p><p>人生中很多問題都來自於結構性原因。每個家庭總以為自己是特別的，但卻忘了每個家庭的生活是如此驚人的相似。許多心理治療師不會在沒有見到青少年患者的家人之前治療，因為他們知道個人的問題並不是在真空中發生的。我們的內在情緒生活絕不只侷限於我們的生活世界，他們總是發生在社會脈絡之中。</p><p>在許多相似結構的社會中，同個角色都有一樣的行為。這時看一個人行為時，重點就從「這一個人個別來說，究竟是好人還是壞人」轉移到「他們所參與的體系本身究竟乘載了多少鼓勵這個行為產生的因子」。例如：家庭暴力犯罪者都具有「男性」、「丈夫」或「父親」身份的事實，有多少是受大眾文化不斷地將控制與暴力當作「真正的男子漢」的根本標記，將控制與暴力光榮化影響呢？</p><p>這不是說所有的錯都是社會的問題，而那些家庭暴力施暴者個人都不需要負任何責任。但是要根本改變目前這種家庭暴力行為模式的話，我們必須了解這些家庭暴力模式和阻力最小的路之間的關聯，以及人們如何決定走上這條阻力最小的路。</p><p>資本主義賦予財富高度價值，給你一個價值觀：「擁有某個你現在尚未擁有的東西，幾乎是解決任何問題的答案。」</p><p>社會結構與文化價值，會給角色想要的內容和取得的能力、如果想要的內容大於其被賦予的取得能力，這個角色就會容易陷入困境。當他陷入困境，人會產生一種緊張、衝突感，想解決這個困境。方法一，壓力下合法認真的工作。方法二，放棄文化價值、跟自己說那些沒什麼了不起的。方法三，用非法的手段取得內容。方法四，反叛，挑戰現有制度及其不公平的機會分配。</p><p>價值的分佈，與滿足這些價值的合法機會分佈，兩個落差越大，偏差行為就越可能產生。但這不意味著高犯罪率是因為人們真的是缺乏他們所需要的東西；這意味著高犯罪率是因為人們缺乏那些旁人都有、而且文化價值告訴他們應該有，而他卻沒有的東西。研究顯示，不論城市的所得平均是多少，在民眾收入最不平等的城市裡，竊盜、搶劫案的發生率最高。</p><p>在結構中加入新的角色，社會體系就會劇烈變化。像是生小孩之後的家庭，會發生一些結構現象。</p><p>如果體系中的人知道結構就是設計成這樣子的話，他們可能會覺得好受一點。不會只怪罪於其他人的改變、對他的行為。</p><p>我們可以問，是體系中的哪些互動模式引起了這個社會現象。</p><p>全力是一種不管對方是否同意，權力擁有者都能控制事件、資源與人們能力；權力是一種掌控、強迫、宰制的工具。</p><p>對自己身處的社會體系問下面的問題。例如：家庭究竟是什麼？家庭為什麼重要？一個經濟體系應該為參與其中的人做些什麼？</p><p>類似文化與社會結構的概念，是我們思考社會生活的工具。讓我們聚焦在生活的不同層面上，最後再把這些東西重新拼裝成一個整體。但這個想法會讓我們把他們視為兩個獨立的事物。但兩者從來未曾獨立存在過。</p><p>結構的每一個面向都和文化象徵、文化概念有關。文化影響結構、結構中的人解釋文化，形成因果循環。</p><h3 id="第四章-人口與人類生態學"><a href="#第四章-人口與人類生態學" class="headerlink" title="第四章 - 人口與人類生態學"></a>第四章 - 人口與人類生態學</h3><p>人 - 社會體系 - 物質環境 - 人，循環。</p><h3 id="第五章-我們、它和社會互動-p177-p206"><a href="#第五章-我們、它和社會互動-p177-p206" class="headerlink" title="第五章 - 我們、它和社會互動 p177~p206"></a>第五章 - 我們、它和社會互動 p177~p206</h3><p>嬰兒不能區辨世界與自己兩者的差別；對他們來說，所有事物都是以他們為中心的一個大「整體」。因此嬰兒無法認知他人是獨立存在的、有思有感的個體。嬰兒只是以事物存在的方式去聽去感覺，並不能理解我和事物的關聯，也不知道如何解釋他們。</p><p>米德提出我們是透過發現他人的內心世界，而學會思索自我的。這些認知最初發生於當人們使用語言談論自己、談論我們、談論任何他們經驗到的事實。語言是連結自我經驗和他人經驗的橋樑。藉由發現他人如何經驗自我，我們發現人類自我的可能性。我們開始意識到自己的觀點，我們以為的事實，其實只是一種觀點。之後就可以用思考其他人一樣，使用概念來思考自我。</p><p>自我如同其他建構出來的事實，也是一個建構出來的事實。從文化概念中建構出一個我們是誰的真實。透過角色關係來認識我們的不只是一般人，我們自己主要也是以這種方式來認識自己。</p><p>我們是依賴外在資訊與自我的資訊，去建構自我的概念和感覺的。外在資訊的來源主要以兩種「他人」的形式存在。一種是對我而言的重要他人(Significant others)；他們像是鏡子一般反映出我們的形象，而我們透過鏡中的形象認識自己是誰。生命初期，自我的資訊都來自於家庭成員、玩伴這些重要他人。社會化之後開始能理解「一般他人」。一般他人不是特定的個人或團體，而是我們的觀念，用觀念想像一般人類會怎麼看待某個社會情境和該情境裡所屬的不同身份的人。</p><p>構成一般他人的概念是文化性的，是對身份擁有者的一組概念。</p><p>人們只看我們的外表，就認為他們知道我們所屬的身份；聯想我們是怎樣的人。就這層意義而言，我們不只以文化的意義建構真實，因為真實不論就身份、角色和一般他人而言，也全都受到結構的影響。(作者認為文化和結構是獨立的兩件事、我認為結構是文化一部份…)</p><p>我們是誰，不在於自己本身，而是由我們對社會體系的參與以及學習如何參與的社會化過程來決定的。我是誰？對誰來說？</p><p>沒有了身份和角色，從社會意義上來說，我們就不存在了。這概念並不減低我們作為人的價值；它僅僅意味著我們的存在超越了個體的範圍，個體既不是一切事物的開端，也不是其終點。有些人拒絕任何既定模式而活，反而使他們的行為符合了某種文化模式。</p><p>我們如何參與體系的關鍵在於社會互動這個概念，而社會互動的關鍵在於行動(Action)和舉止(Behavior)的區別。有意義基礎的舉止就是行動；而行動則是我們與他人互動、參與社會體系和社會生活的基石。</p><p>高夫曼：我們就都像舞台上的演員。不停地自我表演、同時也是觀眾。但我們始終都在做我們自己，即使我們不見得能自在坦然地承認自己在扮演的事實，也不喜歡承認自己用表演來影響他人對我們的觀感。這個我和拒絕承認這是「真實的我」的我，兩者都一樣是真實的「我」。</p><p>如果我們沒有辦法不斷意識到我們的自我和我們所參與的社會生活之間的高度複雜性，進而整合我們的各種角色，會是我們因為無知而參與那些會結惡果的社會體系；也會畫地自限，不企圖改變這些惡行。</p><p>我們是電視劇中的角色，有編劇寫得最小阻力的劇情，但不同的是每個演員也有自我意志去選擇人生中的行動。如果我們在劇本是壞人的角色，並不代表我們是壞人。但也不代表我們只能演出壞人。我們和體系文化之間的關係是動態的、鮮活的。我們創造了世界；世界也造就了我們。我們同時是文化的客體與主體。</p><p>我們就像即興性演出的爵士樂手，沒有學過基礎樂理就不會演奏：必須學會分辨升降記號、大小調，會彈奏不同的和弦，還要能容和節拍、旋律和音調… blah blah。樂手必須知道定義和構成爵士樂這種音樂形式的文化符號和概念；知道這些東西如何影響樂手的思考、聆聽與想像途徑。然而，爵士樂手面對音樂時所依循的社些樂理、文化形式，是他們創作的基礎；樂手可以掰紐玩弄這些「規則」，以一種既熟悉(爵士樂、音樂)又創新的方式，挑戰既有限制。</p><p>社會生活和我們的關係，就像爵士樂和爵士樂手們的關係一樣。</p><p>社會互動是由人們創造和維持一個特定的現實感所用的各種方式所構成的。社會互動透過行動和外表來進行。行動和外表互為表裡。</p><p>社會情境是透過社會真實而界定，而這社會真實也只有在人們主動形塑和維持之下才存在。</p><p>我們不斷的用我們對真實如何建構的知識，來理解外界發生了什麼；以及我們該如何扮演我們的角色，讓世界運轉下去。社會中的真實是透過某些模式的社會行動才存在的。這些維持真實的技巧總是一再重複使用，所以往往這些技巧常有儀式性質。像是兩人相愛的親密關係透過，睡前道晚安、吻、掛上電話前說我愛你，等儀式來維持。就像互動儀式中的許多層面，一直要到某方面偏離了這些固定的儀式，我們才會發現這張網上破了一個洞，少掉的那塊就是他們本來應該做、卻沒有照著做的部分。</p><h3 id="第六章-實踐社會學，思索未來p207-p238"><a href="#第六章-實踐社會學，思索未來p207-p238" class="headerlink" title="第六章 - 實踐社會學，思索未來p207-p238"></a>第六章 - 實踐社會學，思索未來p207-p238</h3><p>「我愛你」是一種有意圖的表演式語言(performative language)，第一次說「我愛你」不僅是取悅他人而已，而是一種邀請，一種意圖的表示，想要改變一種社會關係。</p><p>若要解決社會問題，我們一開始就得把問題的社會面看清楚。如果這點沒做到，那麼我們對於社會問題的解釋，就會不正確，對於解決問題的方向也會有偏差。如果分配方式不改變，就算人再努力讓排列順序改變，最有錢的一部份人、和最窮的一部份人分配到的比例還是一樣的，貧窮的問題一樣不會解決。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;書摘的摘要&quot;&gt;&lt;a href=&quot;#書摘的摘要&quot; class=&quot;headerlink&quot; title=&quot;書摘的摘要&quot;&gt;&lt;/a&gt;書摘的摘要&lt;/h3&gt;&lt;p&gt;社會學是一種讓你看到社會現象背後，整體樣貌的工具，看清楚後就可以尋求一點一滴的改變方法。&lt;/p&gt;
&lt;p&gt;用個人主義的
      
    
    </summary>
    
    
      <category term="社會學" scheme="http://wangchou.github.io/tags/%E7%A4%BE%E6%9C%83%E5%AD%B8/"/>
    
  </entry>
  
  <entry>
    <title>大腦超載時代的思考學 The Organized Mind: Thinking Straight in the Age of Information Overload</title>
    <link href="http://wangchou.github.io/2016/06/01/%E5%A4%A7%E8%85%A6%E8%B6%85%E8%BC%89%E6%99%82%E4%BB%A3%E7%9A%84%E6%80%9D%E8%80%83%E5%AD%B8-The-Organized-Mind-Thinking-Straight-in-the-Age-of-Information-Overload/"/>
    <id>http://wangchou.github.io/2016/06/01/大腦超載時代的思考學-The-Organized-Mind-Thinking-Straight-in-the-Age-of-Information-Overload/</id>
    <published>2016-06-01T10:32:00.000Z</published>
    <updated>2017-12-27T02:52:59.766Z</updated>
    
    <content type="html"><![CDATA[<div class="separator" style="clear: both; text-align: center;"><br>  <iframe width="480" height="320" class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/aR1TNEHRY-U/0.jpg" src="https://www.youtube.com/embed/aR1TNEHRY-U?feature=player_embedded" frameborder="0" allowfullscreen><br>  </iframe><br></div><h3 id="演講摘要："><a href="#演講摘要：" class="headerlink" title="演講摘要："></a>演講摘要：</h3><p>我今天要講三個大主題：多工(Multitasking)、延伸大腦(Brain Extender)、決策(Decision Making)。</p><p>不過在開始之前我想先說一下為什麼我寫了這本書，過去十年的神經科學發現了許多「為什麼大腦對某些事情注意、而對其他事情忽略的」的原因。我相信大多數人都可以用這些資訊來更好的組織時間、家裡的事物、工作環境。</p><p>講了現代資訊過載的問題，一堆數字…。</p><p>我們可以怎麼做？大部分人想嘗試多工，不過現在的研究顯示，多工在人大腦是不存在的，大腦只能快速的在循序中切換。多工會造成釋放和壓力相關的…，幾個小時多工後會很累。大量多工的工作(航管員、同步口譯員) 都會安排中間休息的時間。根據研究，多工會降低產出。但大腦會欺騙自己多工也許是有用的，就像喝醉酒之後覺得自己很好一樣。</p><p>那我們要怎麼辦，我們可以像航管員、同步口譯員一樣中間休息一下。研究顯示這樣會讓員工有更好的生產力和更好的產出。像是每幾個小時就有15分鐘的休息。小睡一下很有用，白天小睡15分鐘有時候等於夜裡睡一個半小時的效力，能提高你的IQ 10點。小睡一下會讓大腦補充用完的 glucose；而中間休息可以讓你進入另一個不同的注意力模式。</p><p>人類大腦有兩種主要的注意力模式：中央主導模式(task positive network)、白日夢模式(default mode of brain / task negative network / mind wandering mode)。在白日夢模式你會開始覺得事物開始連結、以非線性思考的方式。所以在兩個模式交互切換是很重要的。</p><p>注意力切換(attention switching)和決策(decision making)會消耗大腦中的燃料。明確的說，會消耗讓葡萄糖(glucose)，讓葡萄糖是神經元運作代謝需要的物質。而且讓葡萄糖並不能無限量供應，不管是大決定還是小決定都會消耗這個燃料。即使在挑選筆的顏色，你也在消耗人生重要決定的燃料。而切換到白日夢模式會讓你的大腦回到預設模式，讓葡萄糖(glucose)重新恢復。小睡一下、小中斷、去渡個假都很有幫助。當我說小中斷(take a break)指的並不是回電子郵件、去看個電視，這樣並不是中斷(break)。而是真正的中斷，讓你的大腦可以真正的做白日夢(really wander)。而我們每個人都有自己的方式可以開始白日夢模式。這個方式也許是，運動、在自然中散步… 像是快思慢想的作者，每天的下午都會找一段時間在史丹佛校園中散步，據他所說大部分的好想法都是那段時間產生的，這不是巧合，這是一個恢復的行為。</p><p>根據研究，那些一週工作六十小時的人的產出只有比一週工作四十小時的人的產出多七個小時。想一想是不是值得多花二十小時得到多七個小時的產出。</p><p>所以我們該怎麼辦，怎麼專注的做事情？一件專家會做的事是「強迫有生產力的時間」(enforce productivity hours)。他們會在一天中找一段時間，讓那段時間完全不會被中斷、打擾，關掉電子郵件軟體、甚至關掉手機。讓他們能進入全神貫注的狀態。如果你無法關掉電子郵件軟體，因為可能會有突發狀況進來，那試著開一個私下的帳號，告訴其他人有緊急的事才用這個郵件位置。不緊急的事請，送到那個公開不常開的帳號。 很多成功的執行長、藝術家都這樣的切分人生的時間，一次只做好一件事。</p><p>接下來我將切換到談，大腦延伸器(Brain extender)。這是一個簡單的想法。如果你想要有生產力，不要把不需要的東西放進大腦裡。像是聽到明天會下雨，與其在腦袋記著說要帶傘、要帶傘，還不如把這個資訊放到環境裡面去，像是把傘從櫃子拿出來放到門邊，然後它就會在你出門時提醒你。另一個例子是設計心理學中門的例子，為什麼人要記得門要推開還是拉開，直接用設計隱藏預設用途就好(拉的話放門把)，像是廁所的門。另一個方式外部化是我們把事情寫下來。而把事情寫下來，其實比打字下來更適合，因爲寫字時的引發的神經活動是不同的，大腦會更深入的去處理這個資訊。最後一個例子是 Google，我們不用記得細節，只要記得關鍵字，就可以找到我們要的資訊。</p><p>最後我想說的是決策(Decision Making)，我們現在擁有的資訊，能讓我們做出以前不能做出的決策。特別是在醫學上資訊的過載，而醫生並沒有受過大量資訊決策的訓練，像是取得和分析。我覺得我們的教育應該要開始改變，要教導資訊處理(information literacy)，而不是之前教育的大量事實。教導他們要如何有創意的使用這些事實來幫助他們去解決真實世界中的問題。判斷資訊到底是否可信。舉例了醫生決策有多複雜，因為每種藥都有有效率、多種副作用的成功率。我覺得像這種判斷應該從八歲開始教。<br>——<br>29:30 開始 Q&amp;A。</p><p>做決策的時候先把事項排優先順序，在狀態好的時候把大事情處理完。</p><p>注意力缺失症？他們的白日夢模式很強，也就是說他們創意很強，但沒法做不完事情，也許他們可以和其他過度專注的人合作，會很成功。</p><p>Motor learning怎樣會有效率？光只是重複性的運動並不是很有效，你必須有意識地、有目的的做那件事。音樂家叫這個故意練習(deliberately practice)。鋼琴家想像練習時不光只有想像手指怎麼動，還要思考音符的意義…. blah blah practice mindfully.</p><p>夜晚六到十小時的睡眠，會經過一個記憶鞏固(memory consolidation)的過程，神經元會重新重現、處理白天有過的神經活動，然後想辦法讓它進入長期記憶、連結、 儲存他們。如果你白天很努力的工作四到五個小時，取得很多的資訊。這時候小睡一下，大腦會進入睡眠階段，開啟了神經元重啟的按鈕，讓某些迴路變的放鬆，你會預先處理一些資訊讓晚上再做後續處理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br&gt;  &lt;iframe width=&quot;480&quot; height=&quot;320&quot; class=&quot;YOUTUBE-iframe-video&quot; data-thu
      
    
    </summary>
    
    
      <category term="psychology" scheme="http://wangchou.github.io/tags/psychology/"/>
    
  </entry>
  
  <entry>
    <title>使用者故事對照/地圖演講摘要 (User Story Mapping)</title>
    <link href="http://wangchou.github.io/2016/05/28/%E4%BD%BF%E7%94%A8%E8%80%85%E6%95%85%E4%BA%8B%E5%B0%8D%E7%85%A7-%E5%9C%B0%E5%9C%96%E6%BC%94%E8%AC%9B%E6%91%98%E8%A6%81-User-Story-Mapping/"/>
    <id>http://wangchou.github.io/2016/05/28/使用者故事對照-地圖演講摘要-User-Story-Mapping/</id>
    <published>2016-05-28T14:07:00.000Z</published>
    <updated>2017-12-27T02:52:21.833Z</updated>
    
    <content type="html"><![CDATA[<div class="separator" style="clear: both; text-align: center;"><br>  <iframe allowfullscreen class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/AorAgSrHjKM/0.jpg" frameborder="0" height="320" src="https://www.youtube.com/embed/AorAgSrHjKM?feature=player_embedded" width="480"><br>  </iframe><br></div><h3 id="摘要："><a href="#摘要：" class="headerlink" title="摘要："></a>摘要：</h3><p>「使用者故事地圖」是一種資訊架構。其目的是讓人們在設計的過程中更容易「透過溝通來建立共識、對系統有全盤理解」。結構的設計讓人可以持續修改、組織、引用、溝通設計的想法，重視呈現每個想法間的相互關係。是「便利貼技巧」+「使用者中心設計」+「敏捷開發」的整合運用。<br>—<br>講者：Jeff Patton, 來自敏捷的社群、當過軟體工程師、專案經理。</p><p>在當專案經理的時候，接觸到使用者故事 (user story)，當時覺得這個名字很蠢，為什麼要用這個字。過了十年之後才了解故事(story)的意義。故事地圖(story map)是一個說大故事的簡單方法、它把大故事分解成更小的部分。然後對每個部分，實作的人會加上更多的細節把產品做出來。</p><p>我從2000年就開始用故事 (story) 這個字。故事這個字從一開始就被誤解，我接下來會說明故事代表的意思。故事會解決軟體開發中兩個問題，但這兩個問題都不是寫更好的需求 (requirements)。</p><p><strong>第一個問題：寫文件沒啥用 (Documents - just don’t work)</strong><br><strong>第二的問題：太多東西要做 (Too much to build)</strong></p><p>想像一個簡單的電話對話。blah blah 講了光靠電話描述，麵包店做出了許多奇怪的蛋糕。類似事在軟體公司也經常發生。文件寫完之後，做出來的產品就是不對。這邊的問題是，當我們分享、同意和簽署的文件，<strong>我們只能相信每個人是理解的(意指每個人其實理解的都不同)</strong>。之後 Kent 就想出了解決文件問題的方法，那就是不要寫、不要交換文件。用「告訴我你的故事」取代：如果我們能直接討論這個，我們可以一起想辦法 (figure it out together)。</p><p>如果你想說什麼，寫在一張卡上。然後你會找到負責實作的人，一起討論、知道到底做出來會怎樣。用故事這個名字的原因來自「我們怎麼使用它」(how we use them) 而不是「我們怎麼寫它」。有多少人用 Scrum？backlog? 問題在現在的 Scrum 會議中，許多人來參加、許多人都在做自己的事，「故事」本來想要帶入的有效溝通早就被忽略了。常常的情況是幾個人會說話，大部分人就只是在聽、在發呆，<strong>沒有相互溝通每個人理解到的是什麼。因為每個人心中的思考是無法被觀察的，只有當我們說出自己的思考、畫些圖片，我們才能察覺到每個人思考的差異，這時候我們才能真的達成共識 (really get it)。</strong>如此在這個會議之後，當我們說到同樣的東西，才會代表同樣的意思、代表同樣的事情。不然會議中的共識，其實完全沒有達到共識。</p><p>光分享文件、並沒有分享理解 (Shared documents aren’t shared understanding)</p><p>透過文字、圖片的討論會讓每個人建立共同的理解。在 Atlassian，他們在牆上貼的不是工作列表，他們把那些放到 JIRA 軟體。他們貼在牆上的是一堆便利貼 / 草圖 / 線圖稿，每個都代表一個故事。他們討論故事。每個團隊，都有各自的故事們，然後做站立會議中，他們指著牆上的便利貼說，我今天做這個 JIRA Ticket。指的同時也指出了這個 JIRA Ticket 在整個大故事的位置，回憶起細節、為什麼現在要做它。那張便利貼就像一張在夏威夷的照片，<strong>你可以說出照片外的細節，因為便利貼是你們一起討論出來的。</strong></p><p><strong>第一個問題的解法：我們靠說故事 (story telling) 來建造共同理解 (shared understanding)</strong></p><hr><p>我們的工作不是建造軟體，我們的工作是改變這個世界。這聽起來也許有些誇張。但這邊我們講的不是世界和平、非洲的飢荒之類的事。這邊說的<strong>世界指的是我們身邊、我們有能力去改變的事。**</strong>這個世界的邊界是我們的產品<strong>，透過看著會使用產品的人，我們有了新的想法，產生新的需求。需求 (requirements) 的目的就是我們背後有了好想法能夠幫助用產品的人。把現在的世界畫一個圈，有產品後的新世界的畫一個圈，我們要觀察現在世界的產出(output)、新世界有這個產出後的結果 (outcome)，像是產品的使用心得、影響 (Impact)。</strong>先前說的想法 (idea) 的問題是「每個人都有想法」。**所以每個人的想法就會轉成越來越多的事情要做。我們的目標不是加快產生出垃圾(our job is not to build more crap faster)，我們的目標是做更少的產出 (our goal is to build less)。當你做更少的產出，你試圖最小化產出 (output) ，同時最大化結果 (outcome) 和影響 (Impact)。</p><p>之前工作的時候，知道了下一次產品發行的需求列表後，去問他們「使用者是誰？解決了使用者什麼問題？」。得到的答案是：「這些是需求 (requirements)」，當時我就知道需求還有另外一個意思 — 那就是閉上嘴 (shut up)。他們真的以為需求列表，就真的如同字典上的意思代表了必須要做的事。實際上它們並不是… 因為不可能實作所有的需求，光只有需求沒法最小化產出、最大化結果。故事是需求 (requirements) 的解毒劑。</p><p>引用 Kent：「軟體開發已經被需求 (requirement) 這個字導入的錯誤的方向，這個字在字典裡被定義為需要做的事 (something mandatory or obligatory)。這個字帶有絕對和永久的一役、抑制了擁抱變化。需求 (requirements)這個字完全是個錯誤」</p><p>我們要說誰做什麼、怎麼做、為什麼做 (talk about who doing what and why)。討論和協作要專注在誰會用這個產品和他們拿到這個產品之後會怎麼使用它。基本上，你必須要<strong>想通整件事</strong>。舉了一個漂亮的嬰兒形狀蛋糕的例子，蛋糕看起來很漂亮，但要吃的時候就必須把嬰兒切開，這應該是沒有把事情想通的做法。</p><p><strong>第二個問題的答案是：透過理解產品是為了誰、做什麼、為什麼這樣做，來最小化產出。</strong></p><p>如果正確的使用故事，就可以解決這兩個問題。</p><p>但我們會碰到一個問題，很多很棒的想法，怎麼轉變成 scrum 中開發的故事裡 (1~3天可完成、可被估計、可測試、可被展示…)。這邊講一個故事，Rachel 是90年代的一個專案經理，當他去跟工程師問說每個的工作項目是為了誰、為什麼要這樣做的同時？發現工程師瞬間就開始說這個東西好像不是一定要做、也許在別的地方做會更好。很多人根本就沒把事情想通。於是，Rachel 就寫了一個聰明的溝通小卡：</p><p>標題：寫一個好的故事<br>As (who) to (do what) so that (why) 的例子，當作一個容易開始討論的起點 (conversation starter)</p><p>就這樣定義出了常見使用者故事的格式(story template)，但如果用這個格式當作 scrum 中的 backlog 項目，應該會覺得有些卡卡的，因為這個格式本來不是拿來這樣子用的。它本來是在探索階段，拿來引導討論那些大的好想法的，那些要被分成更多 backlog 的項目。</p><p>這邊舉了一個 Gray 用敏捷開發流程開發音樂服務網站的例子，Gray 把所有要做的代辦事項排序之後，就從最優先的事情開始做，進度一直都有進展，但一段時間過去，開始覺得事情做不完，而且無法估計什麼時候整個系統可以上線完成。Gray 這時候就問了，有沒有其他不用敏捷開發流程的方法。這是我碰到他當時的情況。我們一見面談的不是開發方法，而是討論定義想法(Frame the idea)、為什麼要做這個產品、對使用者的了解、使用者的目標是什麼。開始討論想法，寫下想法在便利貼上、移動想法、組織想法。討論使用者一整天會怎麼使用這個產品。Gray 說、然後我用便利貼紀錄下來，這是 Gray 第一次看到整個產品看起來會是怎樣子。之後才開始探索細節，分成更多步驟、替代方法、UI的設計、技術細節。之後就可大概估時間，挑出核心的部分來做，發現這些核心都是之前用待辦事項開發幾個月沒做的部分！！！之後這個產品就順利上線了～</p><p>以上是影片前55分鐘的摘要，後來開始用影片舉例子，還是直接看影片吧~<br>你會看到許多使用者故事地圖開發的過程和樣子。後來還有說 MVP 的概念，提早驗證、提早學會。把 MVP 分成數個階段，讓每個階段都能透過驗證來學習、改變產品方向。和一些其他秘訣… 像是油畫草稿和 protyotyping和迭代的重要性。</p><p>作者的總結：<br>1. 改變你工作的方式：跟別人說故事，而不只是寫故事<br>2. 用簡單的視覺化去代表你說的故事<br>3. 要把整個故事都放到地圖上，來找出最重要的部分<br>4. 把事情想通：減少產出、增加結果和影響<br>5. 建立最小可行產品測試，來學到什麼是市場中最小的和可行的<br>6. 用疊代和漸進的(原型 / 草稿式)的方式來建造產品</p><p>有效率的故事們能幫助每個人朝向產品成功而工作</p><p>Q &amp; A 從一小時二十分開始<br>—<br>就結構來說是把敏捷開發流程中的待辦事項列表用一個某種可變網狀系統資訊結構取代。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;br&gt;  &lt;iframe allowfullscreen class=&quot;YOUTUBE-iframe-video&quot; data-thumbnail-sr
      
    
    </summary>
    
    
      <category term="design" scheme="http://wangchou.github.io/tags/design/"/>
    
      <category term="IA" scheme="http://wangchou.github.io/tags/IA/"/>
    
      <category term="user story mapping" scheme="http://wangchou.github.io/tags/user-story-mapping/"/>
    
  </entry>
  
  <entry>
    <title>資訊架構學是什麼？</title>
    <link href="http://wangchou.github.io/2016/04/29/%E8%B3%87%E8%A8%8A%E6%9E%B6%E6%A7%8B%E5%AD%B8%E6%98%AF%E4%BB%80%E9%BA%BC%EF%BC%9F/"/>
    <id>http://wangchou.github.io/2016/04/29/資訊架構學是什麼？/</id>
    <published>2016-04-28T17:22:00.000Z</published>
    <updated>2017-12-27T02:53:59.679Z</updated>
    
    <content type="html"><![CDATA[<p>這邊試著用解構的方式來說明資訊架構 (information architecture) 這門學問。</p><p>設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。</p><p>所以可以理解「設計資訊架構」的過程中，設計出來的某個東西指是「架構/結構 (architecture / structure)」、而且這個架構的改變對象是「資訊」(information)，接著透過新產生的「資訊互動」達成我們的目的。</p><p>簡單說，資訊架構透過設計「結構」、讓人和「資訊」有不同的互動，來達成我們背後期望的目的。</p><p>舉例來說：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1. 程式碼的資訊架構</span><br><span class="line">結構：檔案命名、目錄名稱、放的位置、如何引用、設計模式</span><br><span class="line">資訊：程式碼</span><br><span class="line">目的：讓程式碼容易被理解、容易修改、容易查找、容易維護</span><br><span class="line"></span><br><span class="line">2. 網站的資訊架構</span><br><span class="line">結構：搜尋列、標籤、sitemap、瀏覽列、超連結、分頁...</span><br><span class="line">資訊：文章、圖片、服務、功能</span><br><span class="line">目的：讓人能找到想要的資訊、讓購買率上升、讓使用者達成他想做的行為</span><br><span class="line"></span><br><span class="line">3. 書本的資訊架構</span><br><span class="line">結構：段落、內容的順序、章節、標題、註解</span><br><span class="line">資訊：文字、圖</span><br><span class="line">目的：讓人更能透過閱讀能理解內容</span><br><span class="line"></span><br><span class="line">4. 愛買的資訊架構</span><br><span class="line">結構：商品走道的規劃、服務台的位置、結帳的位置</span><br><span class="line">資訊：商品、愛買提供的試吃服務</span><br><span class="line">目的：賣出更多商品</span><br><span class="line"></span><br><span class="line">5. 臥室的資訊架構</span><br><span class="line">結構：物品的擺放位置 (櫥櫃裡、牆面)</span><br><span class="line">資訊：物品</span><br><span class="line">目的：主人想...</span><br></pre></td></tr></table></figure></p><h5 id="資訊是相對的"><a href="#資訊是相對的" class="headerlink" title="資訊是相對的"></a>資訊是相對的</h5><p>對不同的人，同樣的資料會是不同的資訊；在不同的環境(context)下，同樣的資料會是不同的資訊。資訊不光只有資料、在電腦科學裡，功能/函數也是資訊的一種。</p><h5 id="設計的目的是多方向的"><a href="#設計的目的是多方向的" class="headerlink" title="設計的目的是多方向的"></a>設計的目的是多方向的</h5><p>有設計者本身的目的、有對使用者的目的、有對其他關係人的目的。也就是說，只要是跟人相關的活動都要理解這些人想要的是什麼、目標是什麼。和使用者中心設計 (User-Centric Design) 一樣。</p><h5 id="設計模式-Design-Pattern-Design-Principle"><a href="#設計模式-Design-Pattern-Design-Principle" class="headerlink" title="設計模式 (Design Pattern / Design Principle)"></a>設計模式 (Design Pattern / Design Principle)</h5><p>只要是設計就會有比較好的設計模式來增加設計的成功率。所以通常我們在資訊架構中所學的就是這些「架構的設計模式」，對不同的資訊、不同的目的、不同的人都會有不同的「架構的設計模式」。評估一個「架構的設計模式」的方式就是觀察資訊擺在這個架構下，資訊到底會有什麼不同，能達到什麼不同互動。</p><h5 id="被架構後的資訊"><a href="#被架構後的資訊" class="headerlink" title="被架構後的資訊"></a>被架構後的資訊</h5><p>資訊經過架構後還是資訊，資訊的不同點不外乎就這些：資訊容易不容易「理解、瀏覽、找到、關聯、傳遞、同步、容錯、不失真、記住、更新、處理、新增、刪除…」 根據不同的設計目的，設計不同結構，讓原來的資訊的這些面向變得不同，以達成我們的目的，這就是資訊架構學的使用方法。</p><h5 id="Domain-Knowledge"><a href="#Domain-Knowledge" class="headerlink" title="Domain Knowledge"></a>Domain Knowledge</h5><p>架構的設計模式太多了、資訊也太多種類、人也太多種，細節就看相關領域的書吧~ 只是時時記得，有「變動世界的架構」的選項，變動後一切就會變得不一樣。就像 google / facebook，完全改變了人們和資訊的互動方式、產生方式。</p><h5 id="facebook的資訊架構"><a href="#facebook的資訊架構" class="headerlink" title="facebook的資訊架構"></a>facebook的資訊架構</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">結構：News feed &amp; notification 系統 &amp; 好友列表</span><br><span class="line">資訊：發文、按讚、分享、加入社群的行為、閱讀時間</span><br><span class="line">目的：讓世界變得充滿萬惡的讚能量、讓人都只看到自己想看的</span><br></pre></td></tr></table></figure><p>最後說一下，其實設計流程是結構的一種、結構也是資訊的一種，從資訊流動來看世界是不是越來越有趣了呢？下圖是資訊架構和其他領域的關係。</p><p><img src="https://2.bp.blogspot.com/-i0LfHhueZE0/VyLLxBozfrI/AAAAAAAA4d0/RNN2m0bbHxY1APCUV5Rn-O9d-Th5sV0XwCKgB/s640/IMG_3868.JPG" alt=""></p><p>在使用者經驗分層中，每層都是息息相關的，如果哪一層壞了，整個就壞了。所以從上圖我們可以知道：要做好資訊架構，我們必須做好設計研究、對內容有了解、對功能有能力去實作；要展現好的資訊架構，我們必須做好互動、介面、資訊、視覺設計，不然光只有好的架構，使用者經驗不會好。所以… 工作的時間到了。</p><p>參考：</p><p>1. Eight Principles of Information Architecture, 2010 - Dan Brown</p><p>2. Information Architecture 100, 2013 - 長谷川敦士</p><p>3. The Elements of User Experience, 2010 - Jesse James Garrett</p><p>4. Information Architecture: blueprints for the web, 2009 - Christina Wodtke and Austin Govella</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這邊試著用解構的方式來說明資訊架構 (information architecture) 這門學問。&lt;/p&gt;
&lt;p&gt;設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。&lt;/p&gt;
&lt;p&gt;所以可以理解「設計資訊架構」的過程中，設計出來的某個東西指是「架構/結構 (arc
      
    
    </summary>
    
    
      <category term="IA" scheme="http://wangchou.github.io/tags/IA/"/>
    
      <category term="ux" scheme="http://wangchou.github.io/tags/ux/"/>
    
  </entry>
  
  <entry>
    <title>”redux.js --- 可預測的狀態容器“ 的 API 使用說明</title>
    <link href="http://wangchou.github.io/2016/04/10/%E2%80%9Dredux-js-%E5%8F%AF%E9%A0%90%E6%B8%AC%E7%9A%84%E7%8B%80%E6%85%8B%E5%AE%B9%E5%99%A8%E2%80%9C-%E7%9A%84-API-%E4%BD%BF%E7%94%A8%E8%AA%AA%E6%98%8E/"/>
    <id>http://wangchou.github.io/2016/04/10/”redux-js-可預測的狀態容器“-的-API-使用說明/</id>
    <published>2016-04-10T07:58:00.000Z</published>
    <updated>2017-12-27T02:51:54.697Z</updated>
    
    <content type="html"><![CDATA[<p>這邊只會透過理解 Redux 的 API來簡介如何使用 Redux。這邊假設讀者都知道 web 中 event / listener 的 pattern。</p><p>如果想要知道 redux 背後的實作細節、原理、動機、Flux、Design Pattern、如何和 UI App 做連結，請看 Dan 的 Redux gitbook、Redux tutorial on EggHead。</p><p><strong>redux 是一個狀態容器 (state container / state machine)</strong></p><p>狀態容器要提供幾個功能<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始容器狀態 _by Redux.createStore(**reducer**)_</span><br><span class="line"><span class="number">2.</span> 取得現在的狀態 _by store.getState()_</span><br><span class="line"><span class="number">3.</span> 狀態改變時，通知相關的程式 _by store.subscribe(**listener**)_</span><br><span class="line"><span class="number">3.</span> 接收事件發生的通知、改變狀態 _by store.dispatch(**action**)_</span><br><span class="line"><span class="number">4.</span> 建立之後改變事件處理方式 _by store.replaceReducer(**reducer**)_</span><br><span class="line"><span class="number">5.</span> 由小的狀態容器組成全域狀態容器 _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_</span><br></pre></td></tr></table></figure></p><p>Flux 專有名詞：store、action、reducer。</p><p>store := 一個狀態容器<br>action := 一個像 Event 一樣有 type 屬性的 javascript object<br>reducer := 一個輸入 state 和 action、回傳新 state 的函數, (state, action) -&gt; new_state</p><p>但 store 是 redux 中唯一一個狀態容器的名字。其實 API 等同於下方這樣子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> _by Redux.createStore(**reducer**)_ 等於 _by Redux(**reducer**)_</span><br><span class="line"><span class="number">2.</span> _by store.getState()_ 等於 _by Redux.getState()_</span><br><span class="line"><span class="number">3.</span> _by store.subscribe(**listener**)_ 等於 _by Redux.addListener(**listener**)_</span><br><span class="line"><span class="number">3.</span> _by store.dispatch(**action**)_ 等於 _by Redux.dispatch(**action**)_</span><br><span class="line"><span class="number">4.</span> _by store.replaceReducer(**reducer**)_ 等於 _by Redux.replaceReducer(**reducer**)_</span><br><span class="line"><span class="number">5.</span> _by 無直接 API，只能透過 combineReducers 來組成root reducer，然後用 root reducer 來建全域 store_</span><br></pre></td></tr></table></figure></p><p>一個狀態容器 = 狀態 + reducer，但 reducer 中可以指定初始狀態、所以一個 reducer 其實可以定義一個狀態容器、等同於一個狀態容器，所以 API 等同於下方這樣子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> _by Redux.initContainer(**reducer**)_ 等於 _by Redux(**container**)_</span><br><span class="line"><span class="number">2.</span> _by Redux.getState()_</span><br><span class="line"><span class="number">3.</span> _by Redux.addListener(**listener**)_</span><br><span class="line"><span class="number">3.</span> _by Redux.dispatch(**action**)_</span><br><span class="line"><span class="number">4.</span> _by Redux.replaceReducer(**reducer**)_ 等於 _by Redux.container.replaceReducer(**container.reducer**)_</span><br><span class="line"><span class="number">5.</span> _by 只能透過 combineReducers 來組成 root reducer，再用它來建全域狀態容器_ 等於 _Redux.combineContainer_</span><br></pre></td></tr></table></figure></p><p>把 combineContainer 用 addContainer 取代，API 可以改寫成這樣子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> 初始容器狀態 _by Redux()_</span><br><span class="line"><span class="number">2.</span> 取得現在的狀態 _by Redux.getState()_</span><br><span class="line"><span class="number">3.</span> 狀態改變時，通知相關的程式 _by Redux.addListener(**listener**)_</span><br><span class="line"><span class="number">3.</span> 接收事件發生的通知、改變狀態 _by Redux.dispatch(**action**)_</span><br><span class="line"><span class="number">4.</span> 建立之後改變事件處理方式 _by Redux.getContainer(**name**).replaceReducer(reducer)_</span><br><span class="line"><span class="number">5.</span> 由小的狀態容器組成全域狀態容器 _by Redux.addContainer(**container**)_</span><br><span class="line"><span class="number">6.</span> 建立小的狀態容器 _by Redux.container(name, initialState, reducers)_</span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 所以翻譯過後 redux api 的使用流程就會變成</span></span><br><span class="line"><span class="keyword">let</span> addReducer = <span class="function">(<span class="params">state, ADD_ACTION</span>) =&gt;</span> state++</span><br><span class="line"><span class="keyword">let</span> subtractReducer = <span class="function">(<span class="params">state, SUBTRACT_ACTION</span>) =&gt;</span> state--</span><br><span class="line"></span><br><span class="line">counterContainer = Redux.container(</span><br><span class="line">  <span class="string">'counter'</span>,</span><br><span class="line">  <span class="number">0</span>,</span><br><span class="line">  [addReducer, substractReducer]</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">Redux.addContainer(counterContainer)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CounterComponent</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">this</span>.stateChangeListener = <span class="function">(<span class="params">state</span>) =&gt;</span> <span class="keyword">this</span>.setState(state)</span><br><span class="line">    Redux.addListener(<span class="keyword">this</span>.stateChangeListener)</span><br><span class="line">  &#125;</span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(Redux.getState().counter)</span><br><span class="line">  &#125;</span><br><span class="line">  onAddButtonClick() &#123;</span><br><span class="line">    Redux.dispatch(ADD_ACTION)</span><br><span class="line">  &#125;</span><br><span class="line">  onSubtractButtonClick() &#123;</span><br><span class="line">    Redux.dispatch(SUBSTRACT_ACTION)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>總結，可以看出來 redux 最大的特點就是用 reducer 來定義 container state 的處理範圍，不能用 event callback 的概念去理解它，一個 reducer 對應到“一組” state、多個 actions。</p><p>所以在 Redux 中 reducer 差不多是 container state scope 等價。也因此在 Redux 中 sub-container / sub-store 的名字完全被省略了，你只能用 reducer 的名字來找到他們影子。只要知道這個規則大概就能夠理解 Redux 了。</p><p>reducer := (state, action) -&gt; new_state (你找不到 container 的名字、它被省略了)</p><h2 id="老實說，我覺得這樣子的開發者經驗很不舒服-bad-UX"><a href="#老實說，我覺得這樣子的開發者經驗很不舒服-bad-UX" class="headerlink" title="老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)"></a>老實說，我覺得這樣子的開發者經驗很不舒服 (bad UX)</h2><p>不知道 re-frame 的 UX 會不會比較好？</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;這邊只會透過理解 Redux 的 API來簡介如何使用 Redux。這邊假設讀者都知道 web 中 event / listener 的 pattern。&lt;/p&gt;
&lt;p&gt;如果想要知道 redux 背後的實作細節、原理、動機、Flux、Design Pattern、如何和 U
      
    
    </summary>
    
    
      <category term="redux" scheme="http://wangchou.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>如何讓程式可維護 / 重構的方向 / 程式開發中的互動設計</title>
    <link href="http://wangchou.github.io/2016/03/04/%E5%A6%82%E4%BD%95%E8%AE%93%E7%A8%8B%E5%BC%8F%E5%8F%AF%E7%B6%AD%E8%AD%B7-%E9%87%8D%E6%A7%8B%E7%9A%84%E6%96%B9%E5%90%91-%E7%A8%8B%E5%BC%8F%E9%96%8B%E7%99%BC%E4%B8%AD%E7%9A%84%E4%BA%92%E5%8B%95%E8%A8%AD%E8%A8%88/"/>
    <id>http://wangchou.github.io/2016/03/04/如何讓程式可維護-重構的方向-程式開發中的互動設計/</id>
    <published>2016-03-04T09:55:00.000Z</published>
    <updated>2017-12-27T02:55:38.602Z</updated>
    
    <content type="html"><![CDATA[<h1 id="要解決的問題："><a href="#要解決的問題：" class="headerlink" title="要解決的問題："></a>要解決的問題：</h1><ul><li><p>當要程式中增加功能、解決 bug 時，能：</p><ul><li>有概念知道「要修改的地方們」在哪</li><li>能快速切換到「要修改的地方們」</li><li>能在「要修改的地方們」之間快速切換<br>*「修改的地方們」很容易修改</li><li>「修改的地方們」不多</li></ul></li><li><p>當程式要重構時，能：</p><ul><li>測試重構後，外部行為是否一樣</li><li>輕易搬移搬動程式、不產生 bug</li></ul></li></ul><h1 id="解法："><a href="#解法：" class="headerlink" title="解法："></a>解法：</h1><p>把程式切成小區塊，每個區塊只負責單一功能，幫這些區塊建立資訊架構，架構中設計狀態的流程管理。對應工作內容規劃工作環境。用多次微重構，代替大改。先重構、再解 bug、最後才寫新功能。在多人開發、或經常重構的專案，對穩定的外部 API 建立自動化測試。</p><h1 id="好習慣："><a href="#好習慣：" class="headerlink" title="好習慣："></a>好習慣：</h1><h2 id="把程式切成小區塊-ex-4-30-行的小-chunks"><a href="#把程式切成小區塊-ex-4-30-行的小-chunks" class="headerlink" title="把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)"></a><u>把程式切成小區塊 ( ex: 4 - 30 行的小 chunks)</u></h2><h3 id="好處："><a href="#好處：" class="headerlink" title="好處："></a>好處：</h3><ul><li>好理解、好修改、也容易增加新功能、能塞進人腦的工作記憶裡</li></ul><p>###</p><ul><li>每個程式區塊 = 一個檔案 or 一個 function or 一個 folding</li><li>每個區塊行數 (after folding)，大於一個螢幕可以顯示時就要 Refactoring</li></ul><h2 id="每個區塊只負責單一功能"><a href="#每個區塊只負責單一功能" class="headerlink" title="每個區塊只負責單一功能"></a><u>每個區塊只負責單一功能</u></h2><h3 id="好處：-1"><a href="#好處：-1" class="headerlink" title="好處："></a>好處：</h3><ul><li>容易重複利用、減少 dependency、容易理解、容易找到 debug</li></ul><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><ul><li>多寫純函數 / Stateless API、良好函數/模組命名、註解輸入/輸出參數<h2 id="建立程式碼的資訊架構"><a href="#建立程式碼的資訊架構" class="headerlink" title="建立程式碼的資訊架構"></a><u>建立程式碼的資訊架構</u></h2><h3 id="好處：-2"><a href="#好處：-2" class="headerlink" title="好處："></a>好處：</h3></li><li>容易找到要修改的地方 (在人很有限的 short-term memory 消散之前)</li></ul><h3 id="方法：-1"><a href="#方法：-1" class="headerlink" title="方法："></a>方法：</h3><h4 id="把程式碼區塊分類"><a href="#把程式碼區塊分類" class="headerlink" title="把程式碼區塊分類"></a>把程式碼區塊分類</h4><ul><li>依功能：模組 / MVC / 前後端 / 測試 / Layout or 細節 / Stable or Develop / Web or iOS or Android</li><li>依架構：樹狀主從架構 / 分階層 / Data Layer / Rendering Layer</li><li>依時間：version</li></ul><h2 id="在架構設計中使用流程管理"><a href="#在架構設計中使用流程管理" class="headerlink" title="在架構設計中使用流程管理"></a><u>在架構設計中使用流程管理</u></h2><h3 id="好處：-3"><a href="#好處：-3" class="headerlink" title="好處："></a>好處：</h3><ul><li>增加可預測性、減少程式碼依賴<h3 id="方法：-2"><a href="#方法：-2" class="headerlink" title="方法："></a>方法：</h3></li><li>單向資料流、State Machine、Single Source of Truth</li></ul><h2 id="對應的工作內容建立環境"><a href="#對應的工作內容建立環境" class="headerlink" title="對應的工作內容建立環境"></a><u>對應的工作內容建立環境</u></h2><h3 id="好處：-4"><a href="#好處：-4" class="headerlink" title="好處："></a>好處：</h3><ul><li><p>在程式碼區塊 / 外在環境中移動時，大腦不會 context switch</p></li><li><p>Web 互動環境設計：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 要規劃在下列環境簡單移動的方法 (環境一樣要有架構、資訊權重)</span><br><span class="line">      a. editor &amp; browsers</span><br><span class="line">      b. shell / server / database / git</span><br><span class="line">      c. editor 中的不同檔案</span><br><span class="line">      d. 同個檔案中的 區塊、行、字母</span><br><span class="line">      e. MDN / stack overflow / Google Search / Github Search</span><br><span class="line">2. IDE / shortcut switch / 多螢幕環境 / 切割螢幕畫面</span><br><span class="line">3. Font / Syntax Highlight / AutoComplete / 文法檢查</span><br></pre></td></tr></table></figure></li></ul><h2 id="Micro-Refactoring"><a href="#Micro-Refactoring" class="headerlink" title="Micro-Refactoring"></a><u>Micro-Refactoring</u></h2><h3 id="好處：-5"><a href="#好處：-5" class="headerlink" title="好處："></a>好處：</h3><ul><li>一次改一點比較好測試、失敗的損失也比較低<h2 id="改程式碼的優先順序：重構-gt-修-bug-gt-增加功能"><a href="#改程式碼的優先順序：重構-gt-修-bug-gt-增加功能" class="headerlink" title="改程式碼的優先順序：重構 &gt; 修 bug &gt; 增加功能"></a><u>改程式碼的優先順序：重構 &gt; 修 bug &gt; 增加功能</u></h2><h3 id="好處：-6"><a href="#好處：-6" class="headerlink" title="好處："></a>好處：</h3></li><li>重構會讓修 bug 變簡單、修完 bug 會讓增加新功能變得簡單<h2 id="為不常改變行為的外部-API-建立自動化測試"><a href="#為不常改變行為的外部-API-建立自動化測試" class="headerlink" title="為不常改變行為的外部 API 建立自動化測試"></a><u>為不常改變行為的外部 API 建立自動化測試</u></h2><h3 id="好處：-7"><a href="#好處：-7" class="headerlink" title="好處："></a>好處：</h3></li><li>每次重構時能夠確定沒有破壞這些 API</li></ul><hr><p>Simplicity is the prerequisite for reliability — by Dijkstra.<space><space><br>因為我們是人類，只有相當有限的注意力、短期記憶和工作記憶空間。</space></space></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;要解決的問題：&quot;&gt;&lt;a href=&quot;#要解決的問題：&quot; class=&quot;headerlink&quot; title=&quot;要解決的問題：&quot;&gt;&lt;/a&gt;要解決的問題：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;當要程式中增加功能、解決 bug 時，能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;有概念知道「
      
    
    </summary>
    
    
      <category term="IA" scheme="http://wangchou.github.io/tags/IA/"/>
    
  </entry>
  
  <entry>
    <title>從買蘋果看工程師和設計師的差別？</title>
    <link href="http://wangchou.github.io/2016/02/08/%E5%BE%9E%E8%B2%B7%E8%98%8B%E6%9E%9C%E7%9C%8B%E5%B7%A5%E7%A8%8B%E5%B8%AB%E5%92%8C%E8%A8%AD%E8%A8%88%E5%B8%AB%E7%9A%84%E5%B7%AE%E5%88%A5%EF%BC%9F/"/>
    <id>http://wangchou.github.io/2016/02/08/從買蘋果看工程師和設計師的差別？/</id>
    <published>2016-02-08T06:04:00.000Z</published>
    <updated>2017-12-27T02:53:06.372Z</updated>
    
    <content type="html"><![CDATA[<p>高中的時候，有個留級的朋友問我，你會不會覺得唸這些東西一點用都沒有。書呆子的我，帶著疑惑問：「為什麼會這樣覺得？」但現在過了 15 年，我真的很想問那時候的我，為什麼不會這樣覺得。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">工程和管理的訓練是解決問題，而設計師受的訓練是發現真正的問題。</span><br><span class="line">--- from 設計的心理學 by Donald A. Norman</span><br></pre></td></tr></table></figure><h3 id="聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。"><a href="#聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。" class="headerlink" title="聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。"></a>聽到「幫我買一顆蘋果」這個問題，工程師會這樣做。</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">工程師：花一小時，找出一大堆的購物網站，列出各種蘋果的價格和評價，然後請你挑最好的一個。</span><br><span class="line"></span><br><span class="line">妹子：我只是想和你見個面聊個天，為什麼我必須要看那麼多資料... 而且還要我上網訂、見不到面，還是放棄治療好了。</span><br></pre></td></tr></table></figure><h3 id="聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。-這邊設計師不含-VD"><a href="#聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。-這邊設計師不含-VD" class="headerlink" title="聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)"></a>聽到「幫我買一顆蘋果」這個問題，設計師會這樣做。(這邊設計師不含 VD)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">情況一：</span><br><span class="line">問：你為什麼要買蘋果？</span><br><span class="line">答: 因為想幫房間增加一點紅色。</span><br><span class="line">問: 為什麼想幫房間增加一點紅色?</span><br><span class="line">答: 因為想把房間變漂亮？</span><br><span class="line">解: 設計師把房間的燈從冷色系換成暖色系。</span><br><span class="line"></span><br><span class="line">情況二：</span><br><span class="line">問：你為什麼要買蘋果？</span><br><span class="line">答：因為我肚子餓。</span><br><span class="line">問：可是你不是剛剛才吃完飯？</span><br><span class="line">答：嗯，對喔。(OS: 我只是看你太閒，要給你一點事做。)</span><br><span class="line"></span><br><span class="line">情況三：</span><br><span class="line">問：你為什麼要買蘋果？</span><br><span class="line">答：因為要吃。</span><br><span class="line">問：你為什麼要吃？</span><br><span class="line">答：我每天都要吃一顆，今天沒帶。你廢話那麼多要幹麻？(OS: 這個下屬理由很多。)</span><br></pre></td></tr></table></figure><p>工程師和管理把問題往下展開。<br>設計師把問題往上展，如果找到更簡單的問題再往下展。</p><h3 id="工程師：直接把問題往下展開："><a href="#工程師：直接把問題往下展開：" class="headerlink" title="工程師：直接把問題往下展開："></a>工程師：直接把問題往下展開：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">優：能最快速找到這個問題的解法。</span><br><span class="line">缺：你解決的可能根本不是重要的問題。</span><br></pre></td></tr></table></figure><h3 id="設計師：把問題往後回推，找新問題解"><a href="#設計師：把問題往後回推，找新問題解" class="headerlink" title="設計師：把問題往後回推，找新問題解"></a>設計師：把問題往後回推，找新問題解</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">優：也許能找到真正需要解的問題、花更少的時間就能解決問題。</span><br><span class="line">缺：別人會以為你不想理他在找藉口。老闆會以為你在故意質疑他。如果原來的問題本來就是對的問題，你只是在浪費時間。</span><br></pre></td></tr></table></figure><h3 id="理性與感性"><a href="#理性與感性" class="headerlink" title="理性與感性"></a>理性與感性</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">「現階段的實際工作中，設計師們無論是在方案的設計還是方案的表達上，往往都顯得感性有餘、理性不足。」</span><br><span class="line">--- by 汪方進 ＠ 阿里巴巴 1688用戶體驗部</span><br></pre></td></tr></table></figure><p>一個設計師，不光只有同理心、邏輯推理能力、各種知識也很重要。沒有知識不能推理啊… 所以工程師們快和我一樣跳進來吧~~~ 當設計界的理性之光。其實就演算法的角度來看，就是兩種不同的方法，各有各的使用時機、各有各的風險報酬，如果要能解決生活中的問題，這兩個都很重要。所以也別分什麼工程、設計、商業，如果有需要就學吧。大學四年可以學一個專業，但人生有多少個四年啊… 是不是該多學幾個專業 XD</p><p>註： 把視覺設計師(VD)和程式設計師特別切出來的原因是：他們的工作都偏向在給定的問題中找解法、做的是實作中一定要做的事。但真正優秀的會去觀察使用者。(工程師的話推薦看：程序員的修煉、駭客與畫家，都有提到這點)</p><p>註：上面的對話都是我的想像舉例，別太認真。想知道真正答案的話，或是測試這個人的工程設計傾向，可以請他幫你買顆蘋果看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;高中的時候，有個留級的朋友問我，你會不會覺得唸這些東西一點用都沒有。書呆子的我，帶著疑惑問：「為什麼會這樣覺得？」但現在過了 15 年，我真的很想問那時候的我，為什麼不會這樣覺得。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr
      
    
    </summary>
    
    
      <category term="design" scheme="http://wangchou.github.io/tags/design/"/>
    
      <category term="design thinking" scheme="http://wangchou.github.io/tags/design-thinking/"/>
    
  </entry>
  
  <entry>
    <title>淺談函數式編程和 React</title>
    <link href="http://wangchou.github.io/2016/01/29/%E6%B7%BA%E8%AB%87%E5%87%BD%E6%95%B8%E5%BC%8F%E7%B7%A8%E7%A8%8B%E5%92%8C-React/"/>
    <id>http://wangchou.github.io/2016/01/29/淺談函數式編程和-React/</id>
    <published>2016-01-29T08:08:00.000Z</published>
    <updated>2017-12-25T02:19:53.077Z</updated>
    
    <content type="html"><![CDATA[<p>函數是有定義介面的運算單元。<space><space><space><space></space></space></space></space></p><p>介面有用的地方是抽象化，你只需要知道輸入什麼(Input)、會得到什麼輸出(Output)，你不用知道它細節是怎麼做到的。其實有個超能力在背後，也沒關係。當然這是在沒有碰到 bug 和有良好文件、不需要修改它的前提之下。<space><space><space><space></space></space></space></space></p><p>再強調一次，你只需要理解輸入(input)會對應到什麼輸出(output)就夠了。<space><space></space></space></p><h3 id="問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？"><a href="#問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？" class="headerlink" title="問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？"></a><u>問題來了，怎樣的輸入和輸出的對應「介面」會容易讓人理解？</u></h3><ul><li>有意義的函數名稱</li><li><p>多寫沒有副作用的純函數</p><ul><li>有可預測性：<br>   每次輸入得到相同的輸出、函數內部不存狀態    </li><li>沒有副作用：<br>   運算過程中不會改到外界的變數，像是不改傳進來的參數、不改可以存取的全域變數。    </li><li>顯式(Explict)：<br>   函數和外界溝通的管道只有，傳進來的參數和回傳值。</li></ul></li><li><p>簡化參數、對資料結構的 Information Architecture 做良好設計</p></li><li><p>用函數來定義函數</p><ul><li>柯里化(Currying)：<br>   透過不同給參數來產生新的函數</li><li>合成(Compose)：<br>   透過 pipeline 串接函數的input和output、隱藏參數，產生新的函數。</li></ul></li></ul><h3 id="函數式編程為什麼強大、有彈性？"><a href="#函數式編程為什麼強大、有彈性？" class="headerlink" title="函數式編程為什麼強大、有彈性？"></a><u>函數式編程為什麼強大、有彈性？</u></h3><ul><li><p>把每個函數切得很小，容易更新、維護、平行處理、多人共同開發、被理解</p></li><li><p>透過合成(Compose)把小函數變成大函數，比用繼承有彈性的多</p></li><li><p>對集合實做 Functor 介面，讓一般函數都可以對集合操作。(array, matrix, tensor)</p></li><li><p>把純和不純的函數分開來管理，容易找到問題點。</p></li></ul><h3 id="函數式編程為什麼難寫？"><a href="#函數式編程為什麼難寫？" class="headerlink" title="函數式編程為什麼難寫？"></a><u>函數式編程為什麼難寫？</u></h3><p>因為函數式編程想要把程式變簡單。但大家都知道「變複雜是簡單的、變簡單是複雜的」。所以這種方式寫程式需要設計、思考，你會是一個程式「設計師」。但如果你現在的專案寫完之後沒人會看、不會再改、不用維護、規模不大，也許函數式編程並不能幫到這個專案多少。</p><h3 id="寫-React-就是實踐函數式編程"><a href="#寫-React-就是實踐函數式編程" class="headerlink" title="寫 React 就是實踐函數式編程"></a><u>寫 React 就是實踐函數式編程</u></h3><ul><li><p>透過自定義元件，定義畫 View 的抽象化函數樹</p></li><li><p>透過 JSX 語法把小函數組合成大的函數 (等同於 compose)</p></li><li><p>鼓勵大家寫 dumb 元件、也就是純函數</p></li><li><p>用唯讀的 props，限制大家不能改傳進來的參數、減少副作用</p></li><li><p>透過導入 flux，把純和不純的函數分開來管理</p><ul><li>純的 (對資料只做讀的動作)：每個元件中的 render function</li><li>不純的 (對資料做讀和寫的動作)：<br>   flux中對 action 的 callback、redux 中的 reducer、父元件傳給子元件的 callback</li><li>glue code：元件中其他的 javascript<br><img src="http://2.bp.blogspot.com/-wg5mnU0UosE/VqsbPjd6AfI/AAAAAAAA4Ak/FN1MAFQndCY/s640/unnamed.jpg" alt=""></li></ul></li></ul><h3 id="從函數式編程的角度看-React-的問題？"><a href="#從函數式編程的角度看-React-的問題？" class="headerlink" title="從函數式編程的角度看 React 的問題？"></a><u>從函數式編程的角度看 React 的問題？</u></h3><ul><li><p>沒有什麼高階的集合操作方法：</p><ul><li>把 lodash.js 集合操作拉進來用？</li><li>用 lenses 的方式來穿透深長不露的 states?</li></ul></li><li><p>沒有簡單的 currying 語法</p><ul><li>像是傳不同參數給 html5 input 元件，生出各式各樣對數字的、email、submit、text的自定義元件。最簡單寫法應該是 </li><li>export function NumberInput(props) { 角括弧input type=“number” {…props} /&gt; }</li><li>PS: function 一定要有名字不然 debug 會很慘。</li></ul></li><li><p>雖然集中管理了不純的函數，但還是很難寫：現在透過修改 store 中的 state 來控制元件，這邊 action 觸發的都是不純的函數，如果元件架構一深，還是會很難改。有解嗎？這邊還沒找到什麼 coding guideline…</p><ul><li>多個 container smart 元件</li><li>flux 的多個 store</li><li>redux 的階層式 reducers</li></ul></li></ul><hr><p>延伸閱讀：<br><a href="https://segment.com/blog/deku-our-functional-alternative-to-react/" target="_blank" rel="noopener">deku: functional alternative to react </a><br><a href="https://medium.com/@dan_abramov/how-to-use-classes-and-sleep-at-night-9af8de78ccb4#.jkarowg5n" target="_blank" rel="noopener">how to use classes and sleep at night (in a functional way)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函數是有定義介面的運算單元。&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;space&gt;&lt;/space&gt;&lt;/space&gt;&lt;/space&gt;&lt;/space&gt;&lt;/p&gt;
&lt;p&gt;介面有用的地方是抽象化，你只需要知道輸入什麼(Input)、會得到什麼輸出(Output)，你不用知道它細節是
      
    
    </summary>
    
    
      <category term="functional programming" scheme="http://wangchou.github.io/tags/functional-programming/"/>
    
      <category term="react" scheme="http://wangchou.github.io/tags/react/"/>
    
  </entry>
  
  <entry>
    <title>Hey Underscore, You&#39;re doing it Wrong! (介紹函數編程)</title>
    <link href="http://wangchou.github.io/2016/01/28/Hey-Underscore-You-re-doing-it-Wrong-%E4%BB%8B%E7%B4%B9%E5%87%BD%E6%95%B8%E7%B7%A8%E7%A8%8B/"/>
    <id>http://wangchou.github.io/2016/01/28/Hey-Underscore-You-re-doing-it-Wrong-介紹函數編程/</id>
    <published>2016-01-28T14:05:00.000Z</published>
    <updated>2017-12-27T02:50:27.139Z</updated>
    
    <content type="html"><![CDATA[<iframe allowfullscreen class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/m3svKOdZijA/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/m3svKOdZijA?feature=player_embedded" width="320"></iframe><hr><p>Curried Function：到拿到所有需要的參數前… 一直回傳新函數的函數。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add3 = add(<span class="number">3</span>);</span><br><span class="line">add3(<span class="number">4</span>); <span class="comment">//return 7</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>)(<span class="number">4</span>); <span class="comment">//weird thing</span></span><br></pre></td></tr></table></figure></p><p>autoCurry in Wu.js will save us<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;.autoCurry();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add3 = add(<span class="number">3</span>);</span><br><span class="line">add3(<span class="number">4</span>) <span class="comment">//7</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>,<span class="number">5</span>) <span class="comment">//8 =&gt; not weird any more!!!</span></span><br></pre></td></tr></table></figure></p><p>但我們為什麼需要 curry？參考下面這個組成新 function getTheOdds 的例子。 有了currying，我們可以透過給予不同參數來建立新的函數。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filter = <span class="function"><span class="keyword">function</span>(<span class="params">f, xs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> xs.filter(f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">filter(isOdd, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">// [1,3,5]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getTheOdds = filter(isOdd);</span><br><span class="line">getTheOdds([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]) <span class="comment">//[1,3,5]</span></span><br></pre></td></tr></table></figure></p><p>再來一個用loadash的酷例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//沒用currying、不函數化的寫法</span></span><br><span class="line"><span class="keyword">var</span> firstTwoLetters = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> _.map(words, <span class="function"><span class="keyword">function</span>(<span class="params">word</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _.first(word, <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函數化的寫法(如果underscore吃參數的方式是反過來的話)</span></span><br><span class="line"><span class="keyword">var</span> firstTwoLetters = _.map(_.first(<span class="number">2</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//更函數化的寫法</span></span><br><span class="line">_.map(_.first(<span class="number">2</span>), [<span class="string">'jim'</span>, <span class="string">'kate'</span>]) <span class="comment">//['ji', 'ka']</span></span><br></pre></td></tr></table></figure></p><p>=&gt; Underscore.js的參數排列法讓currying變得不可能  總結currying的優點有下面四個：</p><ul><li>一般化函數、要傳的變數名消失了</li><li>透過給不同參數就可以生成不同的函數</li><li>更簡潔的定義</li><li>讓函式的組合/合成 (composition) 變的可能</li></ul><hr><p>組合/合成 (composition):用多個函數來組成新函數  簡單的例子，用 first() 和 reverse() 來合成 last 函數<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> last = <span class="function"><span class="keyword">function</span>(<span class="params">xs</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sx = reverse(xs);</span><br><span class="line">  <span class="keyword">return</span> first(sx);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> last = compose(first, reverse);</span><br><span class="line"></span><br><span class="line">last([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">//3</span></span><br></pre></td></tr></table></figure></p><p>另一個例子，chain backwardly<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wordCount = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> words = split(<span class="string">' '</span>, str);</span><br><span class="line">  <span class="keyword">return</span> length(words);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wordCount = compose(length, split(<span class="string">' '</span>));</span><br><span class="line">wordCount(<span class="string">"There is a way to save the world"</span>) <span class="comment">//8</span></span><br></pre></td></tr></table></figure></p><p><strong>Category Theory:</strong> 多個函數組合(compose)，作用域互相對應的理論。Connecting the dot.  總結組合：</p><ul><li>能從其他函數組成新函數</li><li>組合過程中把參數藏起來</li><li>極為高階的寫程式</li><li>有數學理論在後面支持</li></ul><hr><p>Functors  map 打開了後面的 object 然後做一些事、再放回 object<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> plus1 = <span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123; <span class="keyword">return</span> x + <span class="number">1</span> &#125;</span><br><span class="line"></span><br><span class="line">plus1([<span class="number">3</span>]) <span class="comment">//wrong!!</span></span><br><span class="line"></span><br><span class="line">map(plus1, [<span class="number">3</span>]) <span class="comment">//4</span></span><br></pre></td></tr></table></figure></p><p>剛剛舉的例子，map 只能操作 array object、但下面試圖用 map 操作所有 object<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map(plus1, MyObject(<span class="number">3</span>)) <span class="comment">//MyObject(4)</span></span><br><span class="line"></span><br><span class="line">MyObject = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyObject.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> MyObject(f(<span class="keyword">this</span>.val));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果對 object 定義了 map function，它就變成 functor null check的例子、Dynamic Safety：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">map(plus1, Maybe(<span class="number">3</span>)) <span class="comment">//=&gt; Maybe(4)</span></span><br><span class="line"></span><br><span class="line">map(plus1, Maybe(<span class="literal">null</span>)) <span class="comment">//=&gt; Maybe(null)</span></span><br><span class="line"></span><br><span class="line">Maybe = <span class="function"><span class="keyword">function</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Maybe.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.val ? Maybe(f(<span class="keyword">this</span>.val)) : Maybe(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>把 ES6 promise 變 functor 的例子<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">map(populateTable, $.ajax.get(<span class="string">'/posts'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.prototype.map = <span class="function"><span class="keyword">function</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">  <span class="keyword">this</span>.then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span>&#123;</span><br><span class="line">    promise.resolve(f(response));</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再來一個和 html 合作的例子：對有和沒有 user_login 的情況下，更新歡迎頁面。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$div = $(<span class="string">"#myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//dot 會把 user.name 拿出來</span></span><br><span class="line"><span class="keyword">var</span> getGreeting = compose(concat(<span class="string">'Welcome '</span>), dot(<span class="string">'name'</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> updateGreetingHtml = compose($div.html, getGreeting);</span><br><span class="line"></span><br><span class="line">map(updateGreetingHtml, Maybe(App.current_user));</span><br></pre></td></tr></table></figure></p><p>underscore 不讓人 extend map  總結 functor 能:</p><ul><li>改變函數的行為卻不用變動 open/closed principle</li><li>不光只有 map, 還有 reduce &amp; compose *<br>直覺且非私人的 api</li><li>free formulas</li><li>動態型別安全/檢查</li></ul><hr><p>總結：underscore 能變得更加 functional。希望有更 functional 的 library</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;iframe allowfullscreen class=&quot;YOUTUBE-iframe-video&quot; data-thumbnail-src=&quot;https://i.ytimg.com/vi/m3svKOdZijA/0.jpg&quot; frameborder=&quot;0&quot; height=&quot;2
      
    
    </summary>
    
    
      <category term="functional programming" scheme="http://wangchou.github.io/tags/functional-programming/"/>
    
  </entry>
  
  <entry>
    <title>什麼是設計？</title>
    <link href="http://wangchou.github.io/2016/01/01/%E4%BB%80%E9%BA%BC%E6%98%AF%E8%A8%AD%E8%A8%88%EF%BC%9F/"/>
    <id>http://wangchou.github.io/2016/01/01/什麼是設計？/</id>
    <published>2015-12-31T16:43:00.000Z</published>
    <updated>2017-12-23T06:08:08.298Z</updated>
    
    <content type="html"><![CDATA[<div class="separator" style="clear: both; text-align: center;"><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><iframe allowfullscreen class="YOUTUBE-iframe-video" data-thumbnail-src="https://i.ytimg.com/vi/z8qs5-BDXNU/0.jpg" frameborder="0" height="266" src="https://www.youtube.com/embed/z8qs5-BDXNU?feature=player_embedded" width="320"></iframe></span></div><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">&nbsp;<a href="http://www.scielo.cl/pdf/arq/n49/art11.pdf" target="_blank" rel="noopener">Design Q&amp;A by Charles Eames</a> 中譯</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 你對設計的定義是什麼？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 人們可以將設計描述為安排元素來達到特定目的(purpose)的計畫。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計是一種藝術的表現嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 我寧願說是一種目的的表現。它可以… 如果它足夠好，之後會被判斷為藝術。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計是一種為了工業目的的工藝嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 不是，但是設計也許是某些工業問題的解。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計的限界是什麼？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 問題的限界是什麼，設計的限界就是什麼。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計是只關注一部份環境(environment)的學科嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 不。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 它是一種通用表達的方法嗎？(Is it a method of general expression?)</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 不，他是行動的方法。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 它是一個人的創造物嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: &nbsp;不，事實上每個人都會受到前人的影響。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計是團體的產物嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 通常是。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 有設計倫理嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 設計總是有限制，通常也包含倫理這項。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計意味著產品是有用處 (necessarily useful) 的嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 是的，即使用處可能很微小。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 人們可以光為了樂趣的作品合作嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 誰會說樂趣是無用的？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計的過程中要承認限制嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 設計和限制有很大的關係。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 什麼是限制？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 設計問題的有效關鍵：設計師能辨識出越多限制越好、他的對於這些限制一起工作的意願和熱情。限制像是金錢、大小、強度、平衡、表面材料、時間。每個問題都有它自己限制的列表。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計是短暫的嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 有些需求是短暫的。大部份設計是短暫的。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 該朝向短暫還是永恆的設計前進？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 如果是一般性、通用的需求和設計，會朝向永久。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 設計是為了誰？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 需求。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 你曾經被迫接受妥協嗎？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 我從未被迫妥協，但我樂意接受限制。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Q: 練習設計的首要條件是？</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">A: 辨認需求。(Recognition of the needs.)</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">看完影片大概知道，設計和目的、需求、問題、限制是息息相關的。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">—</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">接下來看維基百科上對 &nbsp;Design 的定義。定義來自這篇 paper - <a href="http://paulralph.name/files/2011/01/Ralph-and-Wand-A-Proposal-for-a-Formal-Definition-of-the-Design-Concept.pdf" target="_blank" rel="noopener">A Proposal for a Formal Definition of the Design Concept</a>&nbsp;by Paul Ralph et. al.&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">他提出來的定義如下</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><br><div class="page" title="Page 6"><div class="layoutArea"><div class="column"><span style="font-weight: 700;"><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">Design </span></span><br><span style="font-style: italic;"><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;"><br></span></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;"><span style="font-style: italic;">(noun) </span>a <span style="color: #990000;"><span style="font-style: italic;">specification </span>of an <span style="font-style: italic;">object</span></span>, manifested by an <span style="font-style: italic;"><span style="color: #b45f06;">agent</span></span>, intended to accomplish <span style="font-style: italic;"><span style="color: #38761d;">goals</span></span>, in a particular <span style="font-style: italic;"><span style="color: #0b5394;">environment</span></span>, using a set of <span style="font-style: italic;"><span style="color: #351c75;">primitive components</span></span>, satisfying a set of <span style="font-style: italic;"><span style="color: #741b47;">requirement</span></span><span style="color: #741b47;">s</span>, subject to <span style="font-style: italic;"><span style="color: #b45f06;">constraints</span></span>; </span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;"><br></span>      <span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;"><span style="font-style: italic;">(verb, transitive) </span>to create a design, in an environment (where the de- signer operates)&nbsp;</span></div></div></div><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">看了應該不知道想表達什麼，所以他畫了張圖，這樣就清楚多了。</span><br><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg" target="_blank" rel="noopener"><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><img src="https://1.bp.blogspot.com/-K0vsaB6GQhA/VoVUNkNudHI/AAAAAAAA3-M/vXrBqNi2RSk/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.12.58%2BAM.jpg" alt=""></span></a></div><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">Agent 是設計的人。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">產出(Output)：對某個物件的規範/規格</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">然後這個 Output，要完成某些目的 (Goals)、受到某些限制、滿足一些條件、產出在某個環境、由一些元素所組成。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">舉例來說：</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">平面設計：指的是設計的的產出位在的環境是 2D 平面。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">服務設計、字型設計、介面設計、使用者體驗設計、服裝設計：指的是它們的產出 (Specification of Object) 是什麼。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">物件導向程式設計：指的是 primitive components 是物件、產出是程式。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">使用者導向設計 (UCD)：指的是設計的產出的目的 (Goal) 和使用者有關。</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">作者進一步用動詞來看設計，畫了這個圖，清楚地標明什麼是設計這個動作的輸入 (Input) 和輸出 (Output)</span><br><div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s1600/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg" target="_blank" rel="noopener"><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><img src="https://3.bp.blogspot.com/-mTegFAuq6xU/VoVWkm1N2pI/AAAAAAAA3-c/Djps-IbKZ2g/s640/Screen%2BShot%2B2016-01-01%2Bat%2B12.22.32%2BAM.jpg" alt=""></span></a></div><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">最後他又把這個圖改寫成設計的新定義</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;"><br></span><br><div class="page" title="Page 23"><div class="layoutArea"><div class="column"><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">design activity as a <span style="font-style: italic;"><span style="color: #0b5394;">process</span></span>,&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">executed by an <span style="font-style: italic;"><span style="color: #134f5c;">agent</span></span>,&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">for the purpose of generating a <span style="color: #990000;"><span style="font-style: italic;">specification </span>of an </span><span style="font-style: italic;"><span style="color: #990000;">object</span> </span>based on:&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">&gt; the </span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;"><span style="color: #b45f06;">environment</span> </span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">in which the object will exist,&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">&gt; the </span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;"><span style="color: #7f6000;">goals</span> </span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">ascribed to the object,&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">&gt; the desired structural and behavioral properties of the object (</span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;"><span style="color: #38761d;">requirements</span></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">),&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">&gt; a given set of component types (</span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;"><span style="color: #351c75;">primitives</span></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">),&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">&gt; and </span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-style: italic;"><span style="color: #741b47;">constraints</span> </span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;">that limit the acceptable solutions.&nbsp;</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif; font-size: large;"><br></span><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">有沒有很複雜？簡單說 「設計活動就是在某些限制下，生出某個東西來達成某個目的的過程。」</span><br><span style="font-family: &quot;georgia&quot; , &quot;times new roman&quot; , serif;">好像在說廢話有沒有~~~ XD</span></div></div></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div class=&quot;separator&quot; style=&quot;clear: both; text-align: center;&quot;&gt;&lt;span style=&quot;font-family: &amp;quot;georgia&amp;quot; , &amp;quot;times new roman&amp;quot; 
      
    
    </summary>
    
    
      <category term="design" scheme="http://wangchou.github.io/tags/design/"/>
    
  </entry>
  
  <entry>
    <title>台大不一樣思考社：設計思考工作坊 Day 2</title>
    <link href="http://wangchou.github.io/2015/12/20/%E5%8F%B0%E5%A4%A7%E4%B8%8D%E4%B8%80%E6%A8%A3%E6%80%9D%E8%80%83%E7%A4%BE%EF%BC%9A%E8%A8%AD%E8%A8%88%E6%80%9D%E8%80%83%E5%B7%A5%E4%BD%9C%E5%9D%8A-Day-2/"/>
    <id>http://wangchou.github.io/2015/12/20/台大不一樣思考社：設計思考工作坊-Day-2/</id>
    <published>2015-12-20T14:58:00.000Z</published>
    <updated>2017-12-23T06:08:08.299Z</updated>
    
    <content type="html"><![CDATA[<p><u>組合虛擬人物 （CC）</u></p><p>第二天一早 Recap 的方式就是，從前一天的三個人物中合成一個叫 Jessica 的虛擬的人物 ( Composite Character )，這部分是很主觀的，先基於從現有列出來的 needs 和 insight 選出覺得有發展性的點。最後再藉由腦補內容、畫使用者畫像，像是 Persona 一樣把虛擬人物立體出來，因為花了一整天生出來的人，大家其實對他很熟悉 ( 比隨意的 Persona 熟的多 )。</p><p><u>腦力激盪 &nbsp;(Brain Storming )</u></p><p>CC有幾個 insight，最後選的 insight 是現代人會 Do something 來填補早餐的空白時間、像是滑手機，所以腦力激盪的目標變成就是想出一個「讓早餐時間不是空白時間」的方法。之後就是「不批評」「不打斷的」「不離題」的 Brain Storming 了。因為有了 Jessica，這個每個人都熟悉立體人物，<strong><u>溝通</u></strong>的時候變得方便很多，就像是有了使用者的原型一樣。Brain Storming 就是爽爽的啊，不過這次特別強調了「要延伸」他人想法、「要畫圖」要有「Title」等重點。</p><p>發想的差不多後，用「強迫聯想」的方式做 Brain Storming，這部分也是蠻新奇的，先列出「教室」和「辦公室」裡的不相干用品，然後強迫生出可以滿足人物 insight 的想法，這邊會先卡住，然後只要有人開始分享，就會變得很多神奇的想法出來。最後再把所有的想法大概有 100 個吧，一人數票投票列出幾個、然後在二次投票，二次投票的時候才想起 Jessica，想哪一個想法比較可能滿足她。最後選擇用動的食物吸引注意力的迴轉壽司早餐。(好像是小隊輔提出來的… XD) 還有設定要驗證的幾個小想法，像是少量食物、多樣組合 blah 的</p><p><u>製作原型 (Prototyping)</u></p><p>快樂的 30分鐘 maker 時間，高級的扮家家酒和演戲，多次試驗。大家都玩開了~ 我只能說大家的手做能力很強大。</p><p><u>請使用者測試 ( Testing )</u></p><p>這步真的讓我看到 Prototype 的威力所在，第一個使用者就發現這個原型對使用者的感覺，雖來一進來就盯著移動中的食物，但跟我們思考的不一樣。因為迴轉壽司早餐比較像是有空閒時間才會去的地方，對想省時間的使用者。另外還有會發覺原型的問題，像是輸送列應該一開始就要有早餐在上面、最好加上文字說明。除了輸送列的早餐外，還要有菜單、送茶水的服務生不用帶位，特別強調是週末，悠閒的週六早上十點之類的情境。修一修加上演戲，原型多少有解到空白時間的問題，在第一個 iteration 應該算是不錯吧。</p><p><u>各小隊火力展示 ( Demo )</u></p><p>很意外的是其他六隊都做 App，而且有試著嘗試去解我認為早就被解完的問題：「有效率地得到早餐。」本來以為台灣早餐店林立、便利商店林立，早餐不用跑很遠、更不用自己做，還會剩下什麼需求沒被滿足嗎？結果是「熱騰騰好吃的早餐店要排隊」，於是就寫個注重體驗的訂餐、捷運門口取餐的App，然後第一次實體看到 App 的 Prototype長什麼樣子，點點點、換頁之類的，想到我做網頁、寫 App 錢真的也該先做好 Prototype 找個使用者來用用啊~~~</p><p><u>結語</u><br>這個工作坊是個團隊討論、體驗設計思考流程的好地方。本來以為價位有點高 ( 和我以前辦其他社團活動比 )。不過看到一組請三個陌生人使用者來受測、中午吃的還不錯、設計 conference 都很貴、1:2 的教練學員比，總總因素來說是 C/P 還不錯的。列一下 pros and cons：</p><p>pros:</p><ul><li>可以深入的練習觀察技巧</li><li>思考使用者的需求和需求背後的原因</li><li>快樂的團隊思考、討論體驗</li><li>大量便利貼的利用技巧</li><li>得到一種完整的設計流程體驗</li><li>真實的和使用者接觸</li><li>小隊輔們還蠻用心的</li><li>可以碰到許多願意用溝通、用設計改變世界的人</li><li>小遊戲很好玩</li><li><p>一直放舞曲很High<br>cons:</p></li><li><p>和現實真的有一段距離 (感覺 TA 是學生)</p></li><li>像「人本機構」的只鼓勵、不批評的環境讓「擁抱失敗」變成口號。</li><li>建立「需求」、「insight」、「CC」，的過程中用了大量的假設，推論一錯就 GG</li><li>完全不做現有解法的比較與調查 (像是摩斯訂餐 App)</li><li>不介紹失敗的例子</li><li>過度強調人本，但除了人的需求。技術和商業的重要性都不說明，一個好的偵探除了觀察和推理能力，對事物的知識也是很重要的。</li><li>只有練習三個人以上的團體技巧。<div>—</div><div>有點小進步，不過感覺和 Design Researcher 的路還有好遠好遠。<br>最後有點太專心討論和解題，好像沒有好好認識其他人啊，有點可惜~</div></li></ul><p>心理系的小隊輔一江、設計感的 Jarah、到處出現的 Boy、強大的設計師 美辰、很有主見的獸醫系 元皓、講話有趣的東璋、眼鏡很帥的財金系 軒凱、討厭心智圖但會組織演講的柏儒，這次有點忘記一期一會的決心…</p><p><div>記得感到痛苦和累的時候，稱讚一下自己吧「你努力離開舒適圈了喔 :p」</div></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;u&gt;組合虛擬人物 （CC）&lt;/u&gt;&lt;/p&gt;
&lt;p&gt;第二天一早 Recap 的方式就是，從前一天的三個人物中合成一個叫 Jessica 的虛擬的人物 ( Composite Character )，這部分是很主觀的，先基於從現有列出來的 needs 和 insight 選出
      
    
    </summary>
    
    
      <category term="design" scheme="http://wangchou.github.io/tags/design/"/>
    
      <category term="ux" scheme="http://wangchou.github.io/tags/ux/"/>
    
  </entry>
  
  <entry>
    <title>台大不一樣思考社：設計思考工作坊 Day 1</title>
    <link href="http://wangchou.github.io/2015/12/20/%E5%8F%B0%E5%A4%A7%E4%B8%8D%E4%B8%80%E6%A8%A3%E6%80%9D%E8%80%83%E7%A4%BE%EF%BC%9A%E8%A8%AD%E8%A8%88%E6%80%9D%E8%80%83%E5%B7%A5%E4%BD%9C%E5%9D%8A-Day-1/"/>
    <id>http://wangchou.github.io/2015/12/20/台大不一樣思考社：設計思考工作坊-Day-1/</id>
    <published>2015-12-19T18:08:00.000Z</published>
    <updated>2017-12-23T06:08:08.299Z</updated>
    
    <content type="html"><![CDATA[<p>和藝術不同，設計是一門客觀的學問。重視觀察、基於觀察做出像偵探一樣的推論、做出像科學家一樣的假設，用同理心而不是同情心去理解這一個人的行為和需求、從使用者的角度去看這個世界。</p><p><strong><u>問題是和需求是不同的：</u></strong></p><p>從8層樓高優雅的降落到地表不受傷是一個問題。但大多數人這輩子都不會有這樣的需求。</p><p><u><br></u><u>需求要用動詞來描述而不是名詞：</u><br>需求：「吃到好吃的早餐」 =&gt; 人自動會把行動連接成</p><ol><li>怎麼 「吃到好吃的早餐?」</li><li>為什麼要 「吃到好吃的早餐，原因是什麼？」需求「好吃的早餐」 =&gt; 推理就的莫名其妙的卡住，加上 5W1H 都很不順！</li></ol><p>今天請大家解的題目是「如何提升吃早餐的經驗」。</p><p>流程：<br>&nbsp; &nbsp;1. 先用便利貼討論要訪談使用者的問題、把相近的問題Group後，針對每一類問題畫正字投票.</p><p>&nbsp; &nbsp;2. 街訪：會有一個主訪、副訪和紀錄。大概十分鐘，主訪負責掌握進度、副訪負責見縫插針。</p><p>&nbsp; &nbsp;3. 把數個人紀錄的資訊口述下載，每個人寫下事實 (Fact) 到便利貼上 &amp; 分類。</p><p>==== 以下開始小組討論、瘋狂的 blocking I/O 超花時間，為什麼不繼續平行計算啊 ====<br>&nbsp; &nbsp;4. 試著從事實 (Fact) 中，推出這個人的需求 (need)<br>&nbsp; &nbsp;5. 從這個人的需求 (need)，找出洞察 &nbsp;(insight)</p><p>[來到了 long long complain section]<br>一人一票決定街訪問題，真是不太好，就是一種讓人膚淺思考的快速解決方式吧、然後想問題的時候，好像沒有一個比較好的想法，怎麼問會得到提升早餐經驗的資訊，不過強調 empathize 那這次就不預設立場試試吧</p><p>從列需求就一直卡，用動詞描述真的很重要 ( 回家才看文章才懂 )，然後訪的幾個學生都不是很愛吃早餐，他們的簡單需求早就在這個台灣早餐文化發達、便利商店充斥的環境滿足了。還說「提升早餐體驗」是簡單題目，結果需求列完，洞察完全列不出來。需求出來就解啊，為何要落在為做「設計思考」強說洞察的陷阱裡，Inception 一定要下到第幾層嗎？不過別組有些很順利的，希望明天報告的時候能搞清楚，我們和別人不同在哪？做錯了哪一步？</p><p>另外一個是「提升早餐體驗」的題目定下來了，我們不知道客戶是誰、沒有辦法詢問客戶，沒法想問題背後的問題 / 找到真正要解的問題。然後一開始也沒決定是要生產品還是服務，也沒有定好 TA。最後我們這組 TA 好像是學生，但如果要解這個問題，自身的經驗、非訪談的觀察就不能使用。</p><p>然後很討厭，台上報告有事沒事後面工作人員就很 high 的附和之類的，做設計一定要這樣搞嗎？不過開始前玩小遊戲提神真的還不錯。</p><p>現在的想法就只有，使用者都想跟朋友一起吃早餐，那就請宿舍早餐店提出兩人同行，第二人早餐六折的優惠，這樣所有人的體驗都會好，早餐店也會比較賺錢。</p><hr><p>現在只能安慰自己，花了 1,600 元兩天就發覺 Design Thinking 沒啥用，也是不錯的收穫，反正還有一堆其他的設計流程。 UX 這條路 QQ 回家重看了設計的心理學的 Design Thinking 一章，特別強調不要用訪談耶…Orz</p><p>Don’t try to be original, just try to be good.<br>I don’t want to be interesting, I want to be good.<br>( 不一樣思考又怎樣啊… 解問題為什麼不先 google / survey? )</p><p>明天就是嘴砲的 brain storming~ to be continued.</p><p>延伸閱讀：<br><a href="http://www.seinsights.asia/story/1434/795/2018" target="_blank" rel="noopener">像福爾摩沙一樣解決社會問題 (同情心、同理心、觀察力)</a><br><a href="http://kenshinfujiwara.com/2011/11/problems-are-not-equal-to-needs/" target="_blank" rel="noopener">Problems Are Not Equal to Needs</a><br><a href="http://www.logodesignlove.com/paul-rand-video" target="_blank" rel="noopener">Don’t try to be original, try to be good.</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;和藝術不同，設計是一門客觀的學問。重視觀察、基於觀察做出像偵探一樣的推論、做出像科學家一樣的假設，用同理心而不是同情心去理解這一個人的行為和需求、從使用者的角度去看這個世界。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;u&gt;問題是和需求是不同的：&lt;/u&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="design" scheme="http://wangchou.github.io/tags/design/"/>
    
      <category term="ux" scheme="http://wangchou.github.io/tags/ux/"/>
    
  </entry>
  
  <entry>
    <title>Firebase：前端工程師的神兵利器</title>
    <link href="http://wangchou.github.io/2015/12/06/Firebase%EF%BC%9A%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E5%B8%AB%E7%9A%84%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8/"/>
    <id>http://wangchou.github.io/2015/12/06/Firebase：前端工程師的神兵利器/</id>
    <published>2015-12-06T14:12:00.000Z</published>
    <updated>2017-12-27T02:50:17.543Z</updated>
    
    <content type="html"><![CDATA[<p>Firebase.com 像其他的「後端即服務」( Baas, backend as a service ) 一樣，不過他的 Tutorial 超簡單，你只要會用 node 的 npm 大概就夠了。</p><p><a href="https://www.firebase.com/docs/hosting/quickstart.html" target="_blank" rel="noopener">Firebase官方超簡短教學</a>，看了這個我就被吸引住了。</p><p>React 讓人解決 MVC 中的 View。Firebase 讓人不用建 server、遠端登入，只需要用 web user &nbsp;interface 就建出以 Json 為格式的即時資料庫、Rest Web API、One command deploy ( firebase deploy )、社交帳號的管理 ( Oauth 介面的 Facebook、Google、Twitter blah blah 的登入管理) ，還有靜態 CDN 資料發佈、Custom domain mapping ( 這個要花一點時間等 DNS Propagate )。</p><p>Firebase.com 去年被 Google 買走、Parse.com 前年被 Facebook 買走、Apple 也推出了自家的 CloudKit，這些「後端即服務」的公司，讓你&nbsp;<strong><u>不用再管 Server &amp; 資料庫</u></strong>。你只需要有整理資料的能力 ( Structure Data ) 和前端設計的能力，就能當全端工程師了 :)</p><p>各家都有基本的免費流量，一個月 100 GB ~ 2TB 都有，但一旦升級之後就會變很貴喔 要小心。簡單說，以後 Hackathon 不用找後端工程師了，也不要再傻傻的去 github 找看都看不懂的 Hackathon Starter Kit。</p><hr><p>真心覺得，Startup 剛開始用 Baas 就好，省 Server 和後端工程師的錢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Firebase.com 像其他的「後端即服務」( Baas, backend as a service ) 一樣，不過他的 Tutorial 超簡單，你只要會用 node 的 npm 大概就夠了。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.firebase.
      
    
    </summary>
    
    
      <category term="backend" scheme="http://wangchou.github.io/tags/backend/"/>
    
      <category term="firebase" scheme="http://wangchou.github.io/tags/firebase/"/>
    
      <category term="frontend" scheme="http://wangchou.github.io/tags/frontend/"/>
    
  </entry>
  
  <entry>
    <title>React UI 心得文之一</title>
    <link href="http://wangchou.github.io/2015/12/02/React-UI-%E5%BF%83%E5%BE%97%E6%96%87%E4%B9%8B%E4%B8%80/"/>
    <id>http://wangchou.github.io/2015/12/02/React-UI-心得文之一/</id>
    <published>2015-12-01T18:07:00.000Z</published>
    <updated>2017-12-27T02:51:17.264Z</updated>
    
    <content type="html"><![CDATA[<p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">這週在忙著刻一個大元件，中間有包兩三個中元件、然後中元件下面又會有小元件。要記得React 是負責 UI 的啊，千萬個不該在小元件裡面存 state。存了改了兩天還是會有問題，小元件如果存了狀態，常會有那大元件重 render 的時候，設 property 卻無法更新小元件，因為小元件的 state 不一樣了。兩天之後把大中小元件全部改成 dumb component 真的快樂的不得了，程式碼變少了、邏輯也清楚了。</span><br><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">刻 React 元件的方法：</span></span></p><ol><li><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">盡量刻 Dumb Component，把它當成 function 去想要提供什麼參數</span></li><li><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">parent component 要對 child componet 命名和設 handler(childId, value)</span></li><li><p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">事件發生時就呼叫 parent 傳來的 handler，說你是哪個 child和發生了什麼</span><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">就這樣遞迴做下去，最上層的 App component 就可以知道，哪第三個child component 的第四個 child component 發生了什麼事，然後做一些處理。</span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">客制化 React 元件外觀的方法：</span></div><div></div></p></li><li><p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">幫元件的各種 property 類別放置對應的className</span></p></li><li><p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">用 webpack 的 css loader 幫元件建立 local 的 css scope，然後用一個 scss 檔去管理一個元件，這樣一切都會輕鬆的多。( 參考 React Toolbox )</span><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">其他刻外觀小心得：</span></div></p></li><li><p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">多用 em, rem</span></p></li><li><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">用 css 幫背景上色的方式，快速看物件是否對齊</span></li><li><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">用 Mac 的放大鏡 ( ctrl + 雙指滑動 trackpad )</span></li><li><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">用 css trick cursor 去引導 behavior</span></li><li><p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">用 font-weight 和 color 的 alpha channel 去做細部微調</span><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">學各種 React 相關 Library的方法：一定要<strong><span style="font-size: x-large;"><u>從看完官方的 Tutorial/Guide 開始</u></span></strong>，網路上的介紹文章通常都挑簡單的地方說，十篇有九篇都講一樣的東西，還不如看官方的 Tutorial/Guide 把重要的東西有系統的一次學會。很重要所以特別粗體一下…</span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">使用者經驗部分：</span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">碰到客戶想要重新客製化系統的時候</span></div><div></div></p></li><li><p><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">照他們舊有的行為，模擬跑自己刻的新系統幾次，很快就可以知道缺了什麼、哪裡會生出問題，這樣的方法比在那邊天馬行空的猜測會方便的很多。例子: 新報表系統拿舊系統的許多報表重新打一次。</span></p></li><li><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">用心智圖的方式窮舉可能的行為，不然光是用腦袋想一定會漏掉很多細節。</span><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">和他人合作的部分</span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;"><br></span></div><div><span style="font-family: &quot;helvetica neue&quot; , &quot;arial&quot; , &quot;helvetica&quot; , sans-serif;">一定要定時 Sync 進度，時常 commit。不要隱匿進度落後、缺失、維護 local state，想說這樣可以加班追回來。因為很多事從他人的角度來看會清楚的很多，也方便別人調整。不要裝弱、裝強，快放棄那沒用的自尊心吧。</span></div></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;span style=&quot;font-family: &amp;quot;helvetica neue&amp;quot; , &amp;quot;arial&amp;quot; , &amp;quot;helvetica&amp;quot; , sans-serif;&quot;&gt;這週在忙著刻一個大元件，中間有包兩三個中元件、然後
      
    
    </summary>
    
    
      <category term="react" scheme="http://wangchou.github.io/tags/react/"/>
    
      <category term="javascript" scheme="http://wangchou.github.io/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title>聊預測自己未來的能力</title>
    <link href="http://wangchou.github.io/2015/11/28/%E8%81%8A%E9%A0%90%E6%B8%AC%E8%87%AA%E5%B7%B1%E6%9C%AA%E4%BE%86%E7%9A%84%E8%83%BD%E5%8A%9B/"/>
    <id>http://wangchou.github.io/2015/11/28/聊預測自己未來的能力/</id>
    <published>2015-11-28T07:42:00.000Z</published>
    <updated>2017-12-27T02:53:35.905Z</updated>
    
    <content type="html"><![CDATA[<p>比起預測下一期大樂透號碼的能力，這邊說的「預測未來的能力」跟「對未來的想像力」比較相關，是更日常生活相關的能力，。</p><p>這個故事是我最近一個月經常發生的事，剛剛又發生了。我經常會有沒洗澡就睡覺，隔天要出門去咖啡館寫程式的情況，這時就想還是洗一下澡好了、但為了時間還是不要洗頭好。但進入浴室在熱騰騰的蒸氣中間，就會想熱水洗頭會很舒服，然後就洗頭，舒服的回到房間，吹個頭舒服的弄很久才出門。然後隔天出門時又做了一樣的規劃，嗯 洗澡但不洗頭。</p><p>這故事跟個人工作能力無關，但卻大大了影響了我工作的計畫和效率。我缺乏的是清楚地理解自己在不同環境中，會受到怎樣的環境影響，就簡單地做出計畫。</p><p>如果我清楚地想像就算「現在做了決定不洗頭，等下還是會洗頭」，那在趕時間時，我就會決定不洗澡就出門。如果我清楚地想像到「現在在浴室中洗了頭，會舒服到等下在房間吹頭髮、花半小時東摸摸、西摸摸」，那我可能就會忍住不洗頭。</p><p>在這個小故事中影響不大。但在現實工作中，一樣會有這樣的情況。像是被問「這東西下個禮拜做得出來嗎？」腦袋中的想像是每天加班，努力工作，然後下週準時交差。但現實是，加班個兩天，發生了一些問題、或是加班三天後沒心情工作，這些都和你寫程式的能力無關，但卻會在你承諾的時間交不出東西，拖累整個團隊。</p><p>對自己能力過於樂觀的估計是大忌!!! 會拖累他人進度。</p><p>對自己能力過於悲觀的估計是大忌!!! 會拖累自己成長步調、不敢嘗試。</p><p>這種想像力、對過去歷史的記憶力、也許是可以訓練的。再不然只對自己一定能預測正確的情況做預測，其他情況就清楚明白的放在「不知道」這個類別。</p><p>俗話說得好「人貴自知，知己者明」。<br>努力認識自己吧~ 培養自知之明。</p><h2 id="參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」"><a href="#參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」" class="headerlink" title="參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」"></a>參考：《老子》第三十三章：「知人者智，自知者明；勝人者有力，自勝者強」</h2><p>BTW, 這個能力是很容易被觀察的，只要看一個人有沒有準時完成他的承諾就知道了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;比起預測下一期大樂透號碼的能力，這邊說的「預測未來的能力」跟「對未來的想像力」比較相關，是更日常生活相關的能力，。&lt;/p&gt;
&lt;p&gt;這個故事是我最近一個月經常發生的事，剛剛又發生了。我經常會有沒洗澡就睡覺，隔天要出門去咖啡館寫程式的情況，這時就想還是洗一下澡好了、但為了時間還
      
    
    </summary>
    
    
      <category term="老子" scheme="http://wangchou.github.io/tags/%E8%80%81%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>程式設計法與人生 (Programming Paradigm and Life)</title>
    <link href="http://wangchou.github.io/2015/11/21/%E7%A8%8B%E5%BC%8F%E8%A8%AD%E8%A8%88%E6%B3%95%E8%88%87%E4%BA%BA%E7%94%9F-Programming-Paradigm-and-Life/"/>
    <id>http://wangchou.github.io/2015/11/21/程式設計法與人生-Programming-Paradigm-and-Life/</id>
    <published>2015-11-20T20:06:00.000Z</published>
    <updated>2017-12-23T06:08:08.299Z</updated>
    
    <content type="html"><![CDATA[<div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">解決問題流行的方式有兩種。</span></div><ol><li><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">想出第一步要做什麼，然後開始做、做完再想下一個。</span></li><li><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">是把大問題切成數個小問題一直切到夠小，然後再一個一個做。</span><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個<span style="line-height: normal;"> </span>叫做命令式程式設計、第二個<span style="line-height: normal;"> </span>叫做宣告式程式設計。</span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個<span style="line-height: normal;"> </span>想要回答「怎麼做」、第二個<span style="line-height: normal;"> </span>想要回答「做什麼」。</span><br><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個 是工程師做的事、第二個是設計師做的事。</span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個<span style="line-height: normal;"> </span>叫做敏捷式開發流程、第二個<span style="line-height: normal;"> </span>叫做瀑布式開發流程。</span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><span style="line-height: normal;">第一個</span> <span style="line-height: normal;">叫做</span> connecting the dots<span style="line-height: normal;">、第二個叫做</span> <span style="line-height: normal;">設計研究。</span></span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個<span style="line-height: normal;"> </span>叫貪婪演算法、第二個叫分治演算法。</span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個<span style="line-height: normal;"> </span>叫活在當下、第二個叫有遠見。</span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個 把問題序列化、第二個把問題 心智圖化。</span></div><div style="color: #454545; font-size: 15px; line-height: normal; min-height: 18px;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><br></span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><span style="line-height: normal;">用第一種的人想出了外掛</span> - <span style="line-height: normal;">設計模式</span> (design pattern)<span style="line-height: normal;">。</span></span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><span style="line-height: normal;">用第二種的人想出了外掛</span> - <span style="line-height: normal;">狀態機和不變資料</span> (state machine + immutable data)<span style="line-height: normal;">。</span></span></div><div style="color: #454545; font-size: 15px; line-height: normal; min-height: 18px;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><br></span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">還記得大二演算法排序的作業，標準解法是先做第二個<span style="line-height: normal;"> (qsort)</span>、然後問題變小了就接第一個<span style="line-height: normal;"> (shell sort)</span>。</span></div><div style="color: #454545; font-size: 15px; line-height: normal; min-height: 21px;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><br></span></div><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">各有各的使用時機，冷靜分析後我從函數式編程的信仰者回到無神論者了。</span></div><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第一個適合許多未知、經常變動的問題。</span><br><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">第二個適合有固定答案、行為可預測的問題。</span><br><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;"><br></span><div style="color: #454545; font-size: 15px; line-height: normal;"><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">嗯嗯 不過當然用 react 還是比其他好 XD</span><br><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">—</span><br><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">目標努力 iterative 的 functional programming~&nbsp;</span><br><span style="font-family: Helvetica Neue, Arial, Helvetica, sans-serif;">=&gt; 每次用第一個方法切一小塊問題，用第二個方法解。</span></div></li></ol><p></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;div style=&quot;color: #454545; font-size: 15px; line-height: normal;&quot;&gt;&lt;span style=&quot;font-family: Helvetica Neue, Arial, Helvetica, sans-serif;&quot;&gt;
      
    
    </summary>
    
    
      <category term="functional programming" scheme="http://wangchou.github.io/tags/functional-programming/"/>
    
      <category term="oop" scheme="http://wangchou.github.io/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>參加 FB Hackathon 2015 感想</title>
    <link href="http://wangchou.github.io/2015/11/15/%E5%8F%83%E5%8A%A0-FB-Hackathon-2015-%E6%84%9F%E6%83%B3/"/>
    <id>http://wangchou.github.io/2015/11/15/參加-FB-Hackathon-2015-感想/</id>
    <published>2015-11-15T15:24:00.000Z</published>
    <updated>2017-12-23T06:08:08.299Z</updated>
    
    <content type="html"><![CDATA[<h4 id="FB-Hackathon-比賽篇"><a href="#FB-Hackathon-比賽篇" class="headerlink" title="FB Hackathon 比賽篇"></a>FB Hackathon 比賽篇</h4><p>有點缺乏結束的感覺，這時候放下再前進的方法就是寫篇文，透過寫作把事情組織、整理好。</p><p>這是我第一次參加 Hackathon，這次是 FB 和 Girls in Tech 合辦的，主題是女性和公益。先不論結果、這次真的很新鮮 ( 趕期末作業的 fu )，之前上網研究過的 Hackathon 攻略，但今天完全丟在一邊沒在管… 哈哈</p><p>大家在交誼區自我介紹、聊自己的想做的主題，結果弄了很久大家有一點點熟，到一張桌子旁邊坐了下來就變成一隊!!! 然後我們這隊大部份都是做後端、資料處理的，結果就是 nodejs + java + python 各種語言混合大亂鬥，真的很酷~</p><p>經過聊天，發現大家都是第一次參加、發現大家都是熱心公益的人。前面三個小時，花了長時間 Brain Stroming，一般會得獎的參賽者都是決定好要做什麼才來的，還有偷做的。在 Hackathon 跑快速 BASIC 設計流程真的很神奇，定義問題 (Briefing)、分析已有解法 (Analysis)、思考改進方法(Synthesis)、實作 (Implementaion)、傳達 (Communication)。大概流程都有跑，不過 S &amp; I 的部分有點亂。其他合作流程都有讓人 Hack 團隊的感覺。</p><p>一直看設計研究的初學者，終於有個玩的機會 XD~ 很多不熟的地方，設定 Target Audience、設計 Magic Moment ( 這個沒做… )、列出 User Story ( 這個也沒做… T.T )、設計互動 ( 光流程不算… )、紙牌分數投票法。設計師注重這問題是不是真正的問題，工程師注重的是這問題要怎麼解，Hacker 的精神在這兩個中間。但年紀大了真的開始變得比較嘴砲了… T.T</p><p>我這天在工程師的部分一直撞牆，真的是… 超弱。Node &amp; Express 才摸一週多、Facebook APP 第一次開發 ( 這個真的超多地雷限制 )、mongodb 第一次用、環境設定在 Macbook 卡一卡、在 linode linux server 卡一卡。就像馬拉松配速沒配好一樣，在經過三小時討論、五小時 Coding，我在最後的四小時完全失去戰鬥能力。壓垮我的稻草是從 Facebook 抓圖隨機一直回傳 403。</p><p>真的很感謝強者隊友們，PeiPei / Gordon / Joanne / Leo / Erica，就 12 小時 sprint 的角度來看，第一次還蠻成功的，如果再 iterate 幾次、這個團隊應該會生出好產品的。今天過程真的很好玩~ 有了好同伴，就從在 Panic Zone 變成在 Learning Zone 了。</p><p>會再參加嗎？喔 真的很累，想到下個月還有一場就很崩潰。</p><h4 id="Hackathon-前問題研究篇"><a href="#Hackathon-前問題研究篇" class="headerlink" title="Hackathon 前問題研究篇"></a><strong>Hackathon 前問題研究篇</strong></h4><p>因為主題是女性和公益，賽前大概花了半天看了很多議題，挑出兩個覺得適合的問題。</p><p>1. 增加同理心 (empathy) &amp; 跨出舒適圈 (Comfort Zone) 的主題：<br>&nbsp; &nbsp; &gt; I don’t like that man. I must get to know him better. - 林肯<br>&nbsp; &nbsp; &gt; While nothing is easier then denounce the evil doer, nothing is more difficult than understand him. - 杜斯妥也夫斯基<br>&nbsp; &nbsp; &gt; Step outside of your tiny little world. And step inside of the tiny little world of somebody else. - Sam Richards<br>&nbsp; &nbsp; &gt; Life begins at the end of your comfort zone.<br>&nbsp; &nbsp; &gt;&nbsp;<a href="http://blog.crew.co/getting-out-of-your-comfort-zone-why-its-hard-and-why-you-should/" target="_blank" rel="noopener">comfort zone / learning zone / panic zone</a><br>&nbsp; &nbsp; &gt; Ted影片：<a href="https://www.youtube.com/watch?v=kUEGHdQO7WA" target="_blank" rel="noopener">一個關於同理心的激進實驗</a><br>&nbsp; &nbsp; &gt; 厚書：&nbsp;<a href="http://www.amazon.com/The-Righteous-Mind-Politics-Religion/dp/0307455777" target="_blank" rel="noopener">好人總是自以為是：政治與宗教如何將我們四分五裂</a></p><p>2. 在東亞，特別少女生走自然組：不是因為能力不同、而是因為社會期待。 ( 昨天才突然發現我修大學資工系的課時，從來沒跟女生共事過 )<br>&nbsp; &nbsp; &gt;&nbsp;<a href="https://www.youtube.com/watch?v=kUEGHdQO7WA" target="_blank" rel="noopener">台灣女生不喜歡讀科學，「世界第一」帶來的驚愕與警訊</a><br>&nbsp; &nbsp; &gt;&nbsp;<a href="http://t195-240.dialup.seed.net.tw/99annuals/flying62_2.html" target="_blank" rel="noopener">高中選組男女大不同？性別與高中選組之研究</a></p><h2 id="好好放下、明天再前進-Javascript-和-函數編程的世界、Full-Stack-Developer-之路。"><a href="#好好放下、明天再前進-Javascript-和-函數編程的世界、Full-Stack-Developer-之路。" class="headerlink" title="好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。"></a>好好放下、明天再前進 Javascript 和 函數編程的世界、Full Stack Developer 之路。</h2><p>延伸閱讀：<a href="http://www.appsembler.com/blog/10-tips-for-hackathon-success/" target="_blank" rel="noopener">10 tips for hackathon success</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;FB-Hackathon-比賽篇&quot;&gt;&lt;a href=&quot;#FB-Hackathon-比賽篇&quot; class=&quot;headerlink&quot; title=&quot;FB Hackathon 比賽篇&quot;&gt;&lt;/a&gt;FB Hackathon 比賽篇&lt;/h4&gt;&lt;p&gt;有點缺乏結束的感覺，這時候放
      
    
    </summary>
    
    
      <category term="empathy" scheme="http://wangchou.github.io/tags/empathy/"/>
    
      <category term="hackathon" scheme="http://wangchou.github.io/tags/hackathon/"/>
    
  </entry>
  
</feed>
